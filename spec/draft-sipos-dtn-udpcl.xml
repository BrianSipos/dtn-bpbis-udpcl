<?xml version="1.0" encoding="UTF-8"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" consensus="true" docName="draft-sipos-dtn-udpcl-00" ipr="trust200902" submissionType="IETF" tocInclude="true" updates="I-D.ietf-dtn-bpbis" version="3" xml:lang="en">
  <front>
    <title abbrev="DTN TCPCLv4">
      Delay-Tolerant Networking UDP Convergence Layer Protocol
    </title>
    <seriesInfo name="Internet-Draft" value="draft-sipos-dtn-udpcl-00"/>
    <author fullname="Brian Sipos" initials="B." surname="Sipos">
      <organization abbrev="RKF Engineering">
        RKF Engineering Solutions, LLC
      </organization>
      <address>
        <postal>
          <street>7500 Old Georgetown Road</street>
          <street>Suite 1275</street>
          <city>Bethesda</city>
          <region>MD</region>
          <code>20814-6198</code>
          <country>United States of America</country>
        </postal>
        <email>BSipos@rkf-eng.com</email>
      </address>
    </author>
    <date day="28" month="January" year="2021"/>
    <area>Transport</area>
    <workgroup>Delay-Tolerant Networking</workgroup>
    <abstract>
      <t>
This document describes a UDP-based convergence layer (UDPCL) for Delay-Tolerant Networking (DTN).
This version of the UDPCL protocol clarifies requirements of RFC7122, adds discussion of multicast addressing, and updates to the Bundle Protocol (BP) contents, encodings, and convergence layer requirements in BP Version 7.
Specifically, the UDPCL uses CBOR-encoded BPv7 bundles as its service data unit being transported and provides a reliable transport of such bundles.
This version of UDPCL also includes security and extensibility mechanisms.
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="sec-intro">
      <name>Introduction</name>
      <t>
This document describes the UDP-based convergence-layer protocol for Delay-Tolerant Networking.
Delay-Tolerant Networking is an end-to-end architecture providing communications in and/or through highly stressed environments, including those with intermittent connectivity, long and/or variable delays, and high bit error rates.
More detailed descriptions of the rationale and capabilities of these networks can be found in "Delay-Tolerant Network Architecture" <xref target="RFC4838"/>.
      </t>
      <t>
An important goal of the DTN architecture is to accommodate a wide range of networking technologies and environments.
The protocol used for DTN communications is the Bundle Protocol Version 7 (BPv7) <xref target="I-D.ietf-dtn-bpbis"/>, an application-layer protocol that is used to construct a store-and-forward overlay network.
BPv7 requires the services of a "convergence-layer adapter" (CLA) to send and receive bundles using the service of some "native" link, network, or Internet protocol.
This document describes one such convergence-layer adapter that uses the well-known User Datagram Protocol (UDP).
This convergence layer is referred to as UDP Convergence Layer (UDPCL).
For the remainder of this document, the abbreviation "BP" without the version suffix refers to BPv7.
      </t>
      <t>
The locations of the UDPCL and the BP in the Internet model protocol stack (described in <xref target="RFC1122"/>) are shown in Figure 1.
In particular, when BP is using UDP as its bearer with UDPCL as its convergence layer, both BP and UDPCL reside at the application layer of the Internet model.
      </t>
      <figure anchor="fig-udpcl-ip-stack">
        <name>The Locations of the Bundle Protocol and the UDP Convergence-Layer Protocol above the Internet Protocol Stack</name>
        <artwork align="center" type="ascii-art">
+-------------------------+
|     DTN Application     | -\
+-------------------------|   |
|  Bundle Protocol (BP)   |   -&gt; Application Layer
+-------------------------+   |
| UDP Conv. Layer (UDPCL) |   |
+-------------------------+   |
|     DTLS (optional)     | -/
+-------------------------+
|          UDP            | ---&gt; Transport Layer
+-------------------------+
|       IPv4/IPv6         | ---&gt; Network Layer
+-------------------------+
|   Link-Layer Protocol   | ---&gt; Link Layer
+-------------------------+
</artwork>
      </figure>
      <section>
        <name>Scope</name>
        <t>
This document describes the format of the protocol data units passed between entities participating in UDPCL communications.
This document does not address:
        </t>
        <ul spacing="normal">
          <li>
The format of protocol data units of the Bundle Protocol, as those are defined elsewhere in <xref target="I-D.ietf-dtn-bpbis"/>.
This includes the concept of bundle fragmentation or bundle encapsulation.
The UDPCL transfers bundles as opaque data blocks.
          </li>
          <li>
Mechanisms for locating or identifying other bundle entities (peers) within a network or across an internet.
The mapping of Node ID to potential convergence layer (CL) protocol and network address is left to implementation and configuration of the BP Agent and its various potential routing strategies.
          </li>
          <li>
Logic for routing bundles along a path toward a bundle's endpoint.
This CL protocol is involved only in transporting bundles between adjacent entities in a routing sequence.
          </li>
          <li>
Logic for performing rate control and congestion control of bundle transfers, both incoming and outgoing from a UDPCL entity.
          </li>
          <li>
Policies or mechanisms for issuing Public Key Infrastructure Using X.509 (PKIX) certificates; provisioning, deploying, or accessing certificates and private keys; deploying or accessing certificate revocation lists (CRLs); or configuring security parameters on an individual entity or across a network.
          </li>
          <li>
Uses of Datagram Transport Layer Security (DTLS) which are not based on PKIX certificate authentication (see <xref target="sec-security-tlsnopki"/>) or in which authentication of both entities is not possible (see <xref target="sec-security-tlsnoauth"/>).
          </li>
        </ul>
        <t>
Any UDPCL implementation requires a BP agent to perform those above listed functions in order to perform end-to-end bundle delivery.
        </t>
      </section>
      <section>
        <name>Requirements Language</name>
        <t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>
      <section anchor="sec-term-defs">
        <name>Definitions Specific to the UDPCL Protocol</name>
        <t>
This section contains definitions specific to the UDPCL protocol.
        </t>
        <dl newline="false" spacing="normal">
          <dt>UDPCL Entity:</dt>
          <dd>
            <t>
This is the notional UDPCL application that initiates UDPCL transfers.
This design, implementation, configuration, and specific behavior of such an entity is outside of the scope of this document.
However, the concept of an entity has utility within the scope of this document as the container and initiator of transfers.
The relationship between a UDPCL entity and UDPCL sessions is defined as follows:
            </t>
            <ul spacing="normal">
              <li>
A UDPCL Entity MAY actively perform any number of transfers and should do so whenever the entity has a bundle to forward to another entity in the network.
              </li>
              <li>
A UDPCL Entity MAY support zero or more passive listening elements that listen for transfers from other entities in the network, including non-unicast transfers.
              </li>
            </ul>
            <t>
These relationships are illustrated in <xref target="fig-entity-transfer-relations"/>.
For the remainder of this document, the term "entity" without the prefix "UDPCL" refers to a UDPCL entity.
            </t>
          </dd>
          <dt>UDP Conversation:</dt>
          <dd>
This refers to datagrams exchanged between two network peers, with each peer identified by a (unicast IP address, UDP port) tuple.
Because UDP is connectionless, there is no notion of a conversation being "opened" or "closed".
          </dd>
          <dt>Transfer:</dt>
          <dd>
This refers to the procedures and mechanisms for conveyance of an individual bundle from one entity to one or more destinations.
This version of UDPCL includes a fragmentation mechanism to allow transfers which are larger than the allowable UDP datagram size.
          </dd>
          <dt>Transmit:</dt>
          <dd>
This refers to a transfer outgoing from an entity as seen from that transmitting entity.
          </dd>
          <dt>Receive:</dt>
          <dd>
This refers to a transfer incoming to an entity as seen from that receiving entity.
          </dd>
        </dl>
        <figure anchor="fig-entity-transfer-relations">
          <name>The relationships between UDPCL entities</name>
          <artwork align="center" type="ascii-art">
+----------------------------------------+
|              UDPCL Entity              |
|                                        |      +----------------+
|   +--------------------------------+   |      |                |-+
|   | Actively Initiated Transfer #1 +---------&gt;| Other          | |
|   +--------------------------------+   |      | UDPCL Entity's | |
|                  ...                   |      | Passive        | |
|   +--------------------------------+   |      | Listener       | |
|   | Actively Initiated Transfer #n +---------&gt;|                | |
|   +--------------------------------+   |      +----------------+ |
|                                        |       +-----------------+
|      +---------------------------+     |
|      | +---------------------------+   |      +----------------+
|      | | Optional Passive          |   |      |                |-+
|      +-| Listener(s)               +&lt;---------+ Other          | |
|        +---------------------------+   |      | UDPCL Entity's | |
|                                 ^      |      | Active         | |
|                                 |      |      | Initiator(s)   | |
|                                 +-------------|                | |
+----------------------------------------+      +----------------+ |
                                                 +-----------------+
</artwork>
        </figure>
      </section>
    </section>
    <section anchor="sec-prococol">
      <name>General Protocol Description</name>
      <t>
The service of this protocol is the transmission of DTN bundles via the User Datagram Protocol (UDP).
This document specifies the optional fragmentation of bundles, procedures for DTLS setup and teardown, and a set of messages and entity requirements.
The general operation of the protocol is as follows.
      </t>
      <t>
Fundamentally, the UDPCL is a (logically) unidirectional "transmit and forget" protocol which itself maintains no long-term state and provides no feedback to the transmitter.
The only long-term state related to UDPCL is used by DTLS in its session keeping (which is bound to a UDP conversation).
An entity receiving a bundle from a particular source address-and-port does not imply that the transmitter is willing to accept bundle transfers on that same address-and-port.
It is the obligation of a BP agent and its routing schemes to determine a bundle return path.
      </t>
      <section anchor="sec-cl-services">
        <name>Convergence Layer Services</name>
        <t>
This version of the UDPCL provides the following services to support the over-laying Bundle Protocol agent.
In all cases, this is not an API definition but a logical description of how the CL can interact with the BP agent.
Each of these interactions can be associated with any number of additional metadata items as necessary to support the operation of the CL or BP agent.
        </t>
        <dl newline="false" spacing="normal">
          <dt>Begin Transmission:</dt>
          <dd>
The principal purpose of the UDPCL is to allow a BP agent to transmit bundle data to one or more other entities.
The receiver of each transfer is identified by an (destination) IPv4 or IPv6 address and a UDP port number (see <xref target="sec-operation"/> for details).
The CL does not necessarily perform any transmission queueing, but may block while transmissions are being processed at the UDP layer.
Any queueing of transmissions is the obligation of the BP agent.
          </dd>
          <dt>Transmission Started:</dt>
          <dd>
The UDPCL entity indicates to the BP agent when a bundle transmission begins sending UDP datagrams.
Once started, there is no notion of a UDPCL transmission failure; a BP agent has to rely on bundle-level status reporting to track bundle progress through the network.
Because of potential queueing or DTLS setup time, this may be delayed from the BP agent providing the bundle-to-transmit.
          </dd>
          <dt>Transmission Finished:</dt>
          <dd>
The UDPCL entity indicates to the BP agent when a bundle has been fully transmitted.
This is not a positive indication that any next-hop receiver has either received or processed the transfer.
          </dd>
          <dt>Reception Started:</dt>
          <dd>
The UDPCL entity indicates to the BP agent when a bundle transfer has begun, which may include information about the total size of a fragmented transfer.
          </dd>
          <dt>Reception Success:</dt>
          <dd>
The UDPCL entity indicates to the BP agent when a bundle has been fully transferred from a peer entity.
The transmitter of each transfer is identified by an (source) IP address and a UDP port number (see <xref target="sec-operation"/> for details).
          </dd>
          <dt>Reception Failure:</dt>
          <dd>
The UDPCL entity indicates to the BP agent on certain reasons for reception failure, notably upon an unfinished transfer timeout (see <xref target="sec-ext-transfer"/>).
          </dd>
          <dt>Attempt DTLS Session:</dt>
          <dd>
The UDPCL allows a BP agent to preemptively attempt to establish a DTLS session with a peer entity (see <xref target="sec-udpcl-security"/>).
Each session attempt can send a different set of session negotiation parameters as directed by the BP agent.
          </dd>
          <dt>Close DTLS Session:</dt>
          <dd>
The UDPCL allows a BP agent to preemptively close an established DTLS session with a peer entity.
The closure request is on a per-session basis.
          </dd>
          <dt>DTLS Session State Changed:</dt>
          <dd>
The UDPCL entity indicates to the BP agent when a DTLS session state changes.
The possible DTLS session states are defined in <xref target="RFC6347"/>.
          </dd>
        </dl>
      </section>
      <section anchor="sec-pkix-env">
        <name>PKIX Environments and CA Policy</name>
        <t>
This specification gives requirements about how to use PKIX certificates issued by a Certificate Authority (CA), but does not define any mechanisms for how those certificates come to be.
The UDPCL uses the exact same mechanisms and makes the same assumptions as TCPCL in <xref section="3.4" target="I-D.ietf-dtn-tcpclv4"/>.
        </t>
      </section>
      <section anchor="sec-policy-fragmentation">
        <name>Fragmentation Policies</name>
        <t>
It is a implementation matter for a sending entity to determine the path maximum transmit unit (MTU) to be used as a target upper-bound UDP datagram size.
Some mechanisms to perform MTU discovery are defined in <xref target="RFC8899"/>.
All IP packets sent by a UDPCL entity SHOULD have the "don't fragment" bit set to allow detection of path MTU issues.
        </t>
        <t>
The priority order of fragmentation is the following:
        </t>
        <ol>
          <li>
When possible, bundles too large to fit in one path-MTU-sized packet SHOULD be fragmented at the BP layer.
Bundle payload fragmentation does not help a large bundle if extension blocks are a major contributor to bundle size, so in some circumstances BP layer fragmentation will not reduce the bundle size sufficiently.
It is outside the scope of UDPCL to manage BP agent fragmentation policies; bundles are received from the BP agent either already fragmented or not.
          </li>
          <li>
Bundles too large to fit in one path-MTU-sized packet SHALL be fragmented as a UDPCL transfer (see <xref target="sec-ext-transfer"/>).
Fragmentation at this level treats bundle transfers as opaque data, so it is independent of bundle block sizes or counts.
          </li>
          <li>
All IP packets larger than expected path MTU SHALL be fragmented by the transmitting entity to fit within one path MTU.
Because of the issues listed in <xref section="3.2" target="RFC8085"/>, it is best to avoid IP fragmentation as much as possible.
          </li>
        </ol>
        <t>
A UDPCL entity SHOULD NOT proactively drop an outgoing transfer due to datagram size.
If intermediate network nodes drop IP packets it is an implementation matter to receive network feedback.
        </t>
      </section>
      <section>
        <name>Error Checking Policies</name>
        <t>
The core Bundle Protocol specification assumes that bundles are transferring over an erasure channel, i.e., a channel that either delivers packets correctly or
not at all.
        </t>
        <t>
A UDP transmitter SHALL NOT disable UDP checksums.
A UDP receiver SHALL NOT disable the checking of received UDP checksums.
        </t>
        <t>
Even when UDP checksums are enabled, a small probability of UDP packet corruption remains.
In some environments, it may be acceptable for a BP agent to occasionally receive corrupted input.
In general, however, a UDPCL entity SHOULD insure the a bundle's blocks are either covered by a CRC or a BPSec integrity check.
        </t>
      </section>
      <section>
        <name>Congestion Control Policies</name>
        <t>
The applications using UDPCL for bundle transport SHALL conform to the congestion control requirements of <xref section="3.1" target="RFC8085"/>.
The application SHALL either perform active congestion control of bundles or behave as the Low Data-Volume application as defined in <xref section="3.1.3" target="RFC8085"/>.
        </t>
        <t>
When nodes have bidirectional transfer capability, the bundle deletion reason code "traffic pared" can be used by a receiving agent to signal to the bundle source application that throttling of bundles along that path SHOULD occur.
        </t>
      </section>
    </section>
    <section anchor="sec-operation">
      <name>UDPCL Operation</name>
      <t>
This section defines the UDPCL protocol and its interactions with under-layers (IP and UDP) and over-layers (BP).
The section is organized from the network layer up toward the BP layer.
      </t>
      <section>
        <name>Destination Address</name>
        <t>
The earlier UDPCL specification in <xref target="RFC7122"/> did not include guidance on IP addressing and potential use of multicast, though the architecture of <xref target="RFC4838"/> explicitly includes multicast and anycast as expected network modes.
        </t>
        <t>
The BP agent determines the mapping from destination EID to next-hop CL parameters, including transfer destination address.
Some EIDs represent unicast destinations and others non-unicast destinations as defined in <xref section="4.2.5.1" target="I-D.ietf-dtn-bpbis"/>.
The unicast-ness of an EID does not necessarily correspond with the unicast-ness, as some bundle routing schemes involve attempting multiple parallel paths to a unicast endpoint.
        </t>
        <t>
For unicast transfers to a single node, the destination address SHALL be a unicast IPv4 or IPv6 address.
When performing unicast transfers, a UDPCL entity SHOULD restrict the network to one protected by IPsec or some other under-layer security mechanism (e.g., a virtual private network).
        </t>
        <t>
For multicast transfers to one or more nodes, the destination address SHALL be a multicast IPv4 <xref target="IANA-IPv4-MCAST"/> or IPv6 <xref target="IANA-IPv6-MCAST"/> address.
        </t>
      </section>
      <section>
        <name>UDP Header</name>
        <t>
To perform UDPCL messaging, the active entity SHALL transmit a UDP datagram to a listening passive entity in accordance with <xref target="RFC0768"/>, typically by using the services provided by the operating system.
Destination port number 4556 has been assigned by IANA as the Registered Port number for the UDP convergence layer and SHALL be used as a default.
Other destination port numbers MAY be used per local configuration.
Determining a passive entity's destination port number (if different from the registered UDPCL port number) is up to the implementation.
Any source port number MAY be used for UDPCL transfers.
Typically an operating system assigned number in the UDP Ephemeral range (49152-65535) is used.
        </t>
      </section>
      <section anchor="sec-udpcl-messaging">
        <name>UDPCL Messaging</name>
        <t>
The lower layer of UDPCL communication is individual-datagram messaging.
For backward compatibility with <xref target="RFC7122"/>, UDPCL has no explicit message type identifier.
The message type is inferred by the inspecting the data contents according to the following rules:
        </t>
        <t>
The message type is inferred by the inspecting the data contents according to the following rules:
        </t>
        <dl newline="false" spacing="normal">
          <dt>Keepalive:</dt>
          <dd>
Keepalive data SHALL be a total of four octets all with value 0x00.
Data with a leading octet value of 0x00 SHALL be treated as keepalive.
          </dd>
          <dt>Extension Map:</dt>
          <dd>
All UDPCL extensions SHALL be contained in a CBOR map in accordance with the definitions of <xref target="sec-udpcl-extension"/>.
The encoded Extension Map SHALL NOT have any CBOR tags.
Data with a leading octet value indicating CBOR map (major type 5) SHALL be treated as an Extension Map.
          </dd>
          <dt>Unframed Bundle:</dt>
          <dd>
            <t>
Bundles can be transmitted outside of a (fragmented or not) Transfer item.
This provides backward compatibility with <xref target="RFC7122"/> and a allows a trivial use of UDPCL which is just embedding an encoded bundle in a UDP datagram.
The encoded bundle is one of the following:
            </t>
            <dl>
              <dt>BPv6 Bundle:</dt>
              <dd>
All encoded BP version 6 bundles begin with the version identifier octet 0x06 in accordance with <xref target="RFC5050"/>.
Data with a leading octet value of 0x06 SHALL be treated as a BPv6 bundle.
              </dd>
              <dt>BPv7 Bundle:</dt>
              <dd>
                <t>
All encoded BP version 7 bundles begin with a CBOR array head in accordance with <xref target="I-D.ietf-dtn-bpbis"/>.
Data with a leading octet value indicating CBOR array (major type 4) SHALL be treated as a BPv7 bundle.
                </t>
                <t>
BPv7 bundles transmitted via UDPCL SHALL NOT include any leading CBOR tag.
If the BP agent provides bundles with such tags the UDPCL entity SHALL remove them.
                </t>
              </dd>
            </dl>
          </dd>
          <dt>DTLS Record:</dt>
          <dd>
            <t>
In addition to the UDPCL specific messaging, immediately after a DTLS Initiation (see <xref target="sec-ext-starttls"/>) the DTLS handshake sequence will begin.
Data with a leading octet value of 0x16 SHALL be treated as a DTLS handshake record in accordance with <xref section="4.1" target="RFC6347"/>.
            </t>
            <t>
If the datagram with the DTLS Initiation extension is not received by an entity, the entity SHOULD still detect the DTLS handshake records and start the handshake sequence at that point.
Data with a leading octet value of 0x17--0x19 SHALL be treated as a DTLS sequencing failure; DTLS non-handshake records should never be seen by the UDPCL messaging layer.
            </t>
          </dd>
        </dl>
        <t>
A summary of how a receiving UDPCL entity can interpret the first octet of a datagram is listed in <xref target="tab-message-first-octet"/>.
When inspecting using CBOR major types, the range of values is caused by the CBOR head encoding of <xref target="RFC8949"/>.
        </t>
        <table align="center" anchor="tab-message-first-octet">
          <name>First-Octet Contents</name>
          <thead>
            <tr>
              <th>Octet Value</th>
              <th>Message Content</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0x00</td>
              <td>Keepalive</td>
            </tr>
            <tr>
              <td>0x06</td>
              <td>BPv6 Bundle</td>
            </tr>
            <tr>
              <td>0x16--0x19</td>
              <td>DTLS Record</td>
            </tr>
            <tr>
              <td>0x80--0x9F</td>
              <td>BPv7 Bundle (CBOR array)</td>
            </tr>
            <tr>
              <td>0xA0--0xBF</td>
              <td>Extension Map (CBOR map)</td>
            </tr>
            <tr>
              <td>others</td>
              <td>unused</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="sec-udpcl-extension">
        <name>UDPCL Extension Items</name>
        <t>
Extensions to UDPCL are encoded per-datagram in a single CBOR map as defined in <xref target="sec-udpcl-messaging"/>.
Each UDPCL extension item SHALL be identified by a unique integer (the Extension ID) used as a key in the Extension Map.
Extension ID assignments are listed in <xref target="sec-iana-extension-types"/>.
        </t>
        <t>
Unless prohibited by particular extension type requirements, a single Extension Map MAY contain any combination of extension items.
Receivers SHALL ignore extension items with unknown Extension ID and continue to process known extension items.
        </t>
        <t>
The following subsections define the initial UDPCL extension types.
        </t>
        <section anchor="sec-ext-starttls">
          <name>DTLS Initiation (STARTTLS)</name>
          <t>
This extension item indicates that the transmitter is about to begin a DTLS handshake sequence in accordance with <xref target="sec-udpcl-security"/>.
          </t>
          <t>
The DTLS Initiation value SHALL be an untagged null value.
There are no DTLS parameters actually transmitted as part of this extension, it only serves to indicate to the recipient that the next datagram will be a DTLS ClientHello.
Although the datagram containing this extension is not retransmitted, the DTLS handshake itself will retransmit ClientHello messages until confirmation is received.
          </t>
          <t>
The Extension Map containing a DTLS Initiation item SHALL NOT contain any other items.
A DTLS Initiation item SHALL NOT be present in any message transmitted within a DTLS session.
A receiver of a DTLS Initiation item within a DTLS session SHALL ignore it.
          </t>
          <t>
If the entity is configured to enable exchanging messages according to DTLS 1.2 <xref target="RFC6347"/> or any successors which are compatible with that DTLS ClientHello, the first message in any sequence to a unicast recipient SHALL be an Extension Map with the DTLS Initiation item.
The RECOMMENDED policy is to enable DTLS for all unicast recipients, even if security policy does not allow or require authentication.
This follows the opportunistic security model of <xref target="RFC7435"/>, though an active attacker could interfere with the exchange in such cases (see <xref target="sec-threat-tls-strip"/>).
          </t>
        </section>
        <section anchor="sec-ext-transfer">
          <name>Bundle Transfer</name>
          <t>
This extension item allows CL-layer fragmentation of bundle transfers.
It also allows a bundle transfer to be transmitted along with extension items, which the unframed bundle data does not.
          </t>
          <t>
The Transfer value SHALL be an untagged CBOR array of four items.
The items are defined in the following order:
          </t>
          <dl>
            <dt>Transfer ID:</dt>
            <dd>
This field SHALL be a CBOR unit item, which is used to correlate multiple fragments.
            </dd>
            <dt>Total Length:</dt>
            <dd>
This field SHALL be a CBOR unit item, which is used to indicate the total length (in octets) of the transfer.
If multiple Transfers for the same Transfer ID are received with differing Total Length values, the receiver SHALL treat the transfer as being malformed.
            </dd>
            <dt>Fragment Offset:</dt>
            <dd>
This field SHALL be a CBOR unit item, which is used to indicate the offset (in octets) into the transfer for the start of this fragment.
            </dd>
            <dt>Fragment Data:</dt>
            <dd>
This field SHALL be a CBOR bstr item, in which the fragment data is contained.
The bstr itself indicates the length of the fragment data.
            </dd>
          </dl>
          <section anchor="sec-transfer-id">
            <name>Bundle Transfer ID</name>
            <t>
Each Transfer item contains a Transfer ID which is used to correlate messages for a single bundle transfer.
A Transfer ID does not attempt to address uniqueness of the bundle data itself and has no relation to concepts such as bundle fragmentation.
Each invocation of UDPCL by the BP agent, requesting transmission of a bundle (fragmentary or otherwise), results in the initiation of a single UDPCL transfer.
            </t>
            <t>
Because UDPCL operation is connectionless, Transfer IDs from each entity SHALL be unique for the operating duration of the entity.
In practice, the ID needs only be unique for the longest receiver reassembly time window; but because that information is not part of the protocol there is no way for an entity to 
When there are bidirectional bundle transfers between UDPCL entities, an entity SHOULD NOT rely on any relation between Transfer IDs originating from each side of the conversation.
            </t>
            <t>
Although there is not a strict requirement for Transfer ID initial values or ordering (see <xref target="sec-security-xferid"/>), in the absence of any other mechanism for generating Transfer IDs an entity SHALL use the following algorithm:
the initial Transfer ID from each entity is zero;
subsequent Transfer ID values are incremented from the prior Transfer ID value by one;
upon exhaustion of the entire 64-bit Transfer ID space, the subsequent Transfer ID value is zero.
            </t>
          </section>
          <section anchor="sec-transfer-fragmentation">
            <name>Transfer Fragmentation and Reassembly</name>
            <t>
The full data content of a transfer SHALL be either a BPv6 or BPv7 Bundle as defined in <xref target="sec-udpcl-messaging"/>.
A receiving entity SHALL discard any reassembled transfer which does not properly contain a bundle.
            </t>
            <t>
A transmitting entity MAY produce a Transfer with a single fragment (i.e., a Fragment Data size identical to the Total Length).
A transmitting entity SHALL NOT produce Transfer fragments with overlapping span.
A transmitting entity SHOULD transmit Transfer fragments in order of Fragment Offset; this makes the behavior deterministic.
            </t>
            <t>
Because of the nature of UDP transport, there is no guaranteed order or timing of received Transfer items.
A receiving entity SHALL consider a transport as finished when Fragment Data has been received which fully covers the Total Length of the transfer.
            </t>
            <t>
A receiving entity SHALL discard any Transfer item containing different CBOR types than defined in this document.
A receiving entity SHALL discard any Transfer item containing a fragment with an overlapping span.
Because there is no feedback indication at the UDPCL layer, a transmitter has no indication when a transfer is discarded by the receiver.
            </t>
            <t>
A receiving entity SHOULD discard unfinished transfer state after an implementation-defined timeout since the last received fragment.
Entities SHOULD choose a transfer timeout interval no longer than one minute (60 seconds).
Discarding an unfinished transfer causes no indication to the transmitting entity, but does indicate this to the BP agent.
            </t>
          </section>
        </section>
      </section>
      <section anchor="sec-udpcl-security">
        <name>UDPCL Security</name>
        <t>
This version of the TCPCL supports establishing a DTLS session within an existing UDP conversation.
When DTLS is used within the UDPCL it affects the entire conversation.
        </t>
        <t>
Once established, the lifetime of a DTLS session SHALL be bound by the DTLS session ticket lifetime or either peer sending a Closure Alert record.
        </t>
        <t>
Subsequent DTLS session attempts to the same passive entity MAY attempt to use the DTLS session resumption feature.
There is no guarantee that the passive entity will accept the request to resume a DTLS session, and the active entity cannot assume any resumption outcome.
        </t>
        <section anchor="sec-dtls-handshake">
          <name>DTLS Handshake</name>
          <t>
The signaling for TLS Initiation is described in <xref target="sec-ext-starttls"/>.
After sending or receiving an Extension Map containing a DTLS Initiation item, an entity SHALL begin the handshake procedure of <xref section="4.2" target="RFC6347"/>.
By convention, this protocol uses the entity which sent the DTLS Initiation (the active peer) as the "client" role of the TLS handshake request.
          </t>
          <t>
Upon receiving an unexpected ClientHello record outside of a DTLS session, an entity SHALL begin the DTLS handshake procedure as if a DTLS Initiation had been received.
This allows recovering from a dropped packet containing DTLS Initiation.
          </t>
        </section>
        <section anchor="sec-dtls-authentication">
          <name>DTLS Authentication</name>
          <t>
The function and mechanism of DTLS authentication for UDPCL is exactly the same as that defined for TCPCL in <xref section="4.4.4" target="I-D.ietf-dtn-tcpclv4"/>.
          </t>
        </section>
      </section>
    </section>
    <section removeInRFC="true">
      <name>Implementation Status</name>
      <t>
[NOTE to the RFC Editor: please remove this section before publication, as well as the reference to <xref target="RFC7942"/>, <xref target="github-dtn-demo-agent"/>, and <xref target="github-dtn-wireshark"/>.]
      </t>
      <t>
This section records the status of known implementations of the protocol defined by this specification at the time of posting of this Internet-Draft, and is based on a proposal described in <xref target="RFC7942"/>.
The description of implementations in this section is intended to assist the IETF in its decision processes in progressing drafts to RFCs.
Please note that the listing of any individual implementation here does not imply endorsement by the IETF.
Furthermore, no effort has been spent to verify the information presented here that was supplied by IETF contributors.
This is not intended as, and must not be construed to be, a catalog of available implementations or their features.
Readers are advised to note that other implementations can exist.
      </t>
      <t>
An example implementation of the this draft of UDPCL has been created as a GitHub project <xref target="github-dtn-demo-agent"/> and is intended to use as a proof-of-concept and as a possible source of interoperability testing.
This example implementation uses D-Bus as the CL-BP Agent interface, so it only runs on hosts which provide the Python "dbus" library.
      </t>
      <t>
A wireshark dissector for UDPCL has been created as a GitHub project <xref target="github-dtn-wireshark"/> and has been kept in-sync with the latest encoding of this specification.
      </t>
    </section>
    <section anchor="sec-security">
      <name>Security Considerations</name>
      <t>
This section separates security considerations into threat categories based on guidance of BCP 72 <xref target="RFC3552"/>.
      </t>
      <section>
        <name>Threat: Passive Leak of Node Data</name>
        <t>
When used without DTLS security, the UDPCL can expose the Node ID and other configuration data to passive eavesdroppers.
This can occur even if no bundle transfers are transmitted.
This can be avoided by always using DTLS, even if authentication is not available (see <xref target="sec-security-tlsalt"/>).
        </t>
      </section>
      <section>
        <name>Threat: Passive Leak of Bundle Data</name>
        <t>
UDPCL can be used to provide point-to-point unicast transport security, but does not provide multicast security, security of data-at-rest, and does not guarantee end-to-end bundle security.
In those cases the bundle security mechanisms defined in <xref target="I-D.ietf-dtn-bpsec"/> are to be used instead.
        </t>
        <t>
When used without DTLS security, the UDPCL exposes all bundle data to passive eavesdroppers.
This can be avoided by always using DTLS for unicast messaging, even if authentication is not available (see <xref target="sec-security-tlsalt"/>).
        </t>
      </section>
      <section anchor="sec-threat-tls-strip">
        <name>Threat: Transport Security Stripping</name>
        <t>
When security policy allows non-DTLS messaging, UDPCL does not protect against active network attackers.
It is possible for a on-path attacker to drop or alter packets containing Extension Map and/or DTLS handshake records, which will cause the receiver to not negotiate a DTLS session.
This leads to the "SSL Stripping" attack described in <xref target="RFC7457"/>.
        </t>
        <t>
When DTLS is available on an entity, it is strongly encouraged that the security policy disallow non-DTLS messaging for unicast purposes.
This requires that the DTLS handshake occurs before any other UDPCL messaging, regardless of the policy-driven parameters of the handshake and policy-driven handling of the handshake outcome.
        </t>
        <t>
One mechanism to mitigate the possibility of DTLS stripping is the use of DNS-based Authentication of Named Entities (DANE) <xref target="RFC6698"/> toward the passive peer.
This mechanism relies on DNS and is unidirectional, so it doesn't help with applying policy toward the active peer, but it can be useful in an environment using opportunistic security.
The configuration and use of DANE are outside of the scope of this document.
        </t>
        <t>
The negotiated use of DTLS is identical behavior to STARTTLS use in <xref target="RFC2595"/>, <xref target="RFC4511"/>, and others.
        </t>
      </section>
      <section>
        <name>Threat: Weak DTLS Configurations</name>
        <t>
Even when using DTLS to secure the UDPCL session, the actual ciphersuite negotiated between the DTLS peers can be insecure.
Recommendations for ciphersuite use are included in BCP 195 <xref target="RFC7525"/>.
It is up to security policies within each UDPCL entity to ensure that the negotiated DTLS ciphersuite meets transport security requirements.
        </t>
      </section>
      <section anchor="sec-threat-untrust-cert">
        <name>Threat: Untrusted End-Entity Certificate</name>
        <t>
The profile in <xref target="sec-dtls-authentication"/> uses end-entity certificates chained up to a trusted root CA.
During DTLS handshake, either entity can send a certificate set which does not contain the full chain, possibly excluding intermediate or root CAs.
In an environment where peers are known to already contain needed root and intermediate CAs there is no need to include those CAs, but this has a risk of an entity not actually having one of the needed CAs.
        </t>
      </section>
      <section>
        <name>Threat: Certificate Validation Vulnerabilities</name>
        <t>
Even when DTLS itself is operating properly an attacker can attempt to exploit vulnerabilities within certificate check algorithms or configuration to establish a secure DTLS session using an invalid certificate.
An invalid certificate exploit could lead to bundle data leaking and/or denial of service to the Node ID being impersonated.
        </t>
        <t>
There are many reasons, described in <xref target="RFC5280"/> and <xref target="RFC6125"/>, why a certificate can fail to validate, including using the certificate outside of its valid time interval, using purposes for which it was not authorized, or using it after it has been revoked by its CA.
Validating a certificate is a complex task and can require network connectivity outside of the primary UDPCL network path(s) if a mechanism such as OCSP <xref target="RFC6960"/> is used by the CA.
The configuration and use of particular certificate validation methods are outside of the scope of this document.
        </t>
      </section>
      <section anchor="sec-threat-node-impersonation">
        <name>Threat: BP Node Impersonation</name>
        <t>
The UDPCL does not provide any guarantees of or binding to the source of transferred bundles.
        </t>
        <t>
One mitigation is to use the block integrity mechanisms defined in <xref target="I-D.ietf-dtn-bpsec"/> with a security context which provides node identity binding.
        </t>
      </section>
      <section>
        <name>Threat: Denial of Service</name>
        <t>
The behaviors described in this section all amount to a potential denial-of-service to a UDPCL entity.
The denial-of-service could be limited to an individual UDPCL entity, or could affect all entities on a host or network segment.
        </t>
        <t>
An entity can send a large amount of data to a UDPCL entity, requiring the receiving entity to handle the data.
The victim entity can block UDP packets from network peers which are thought to be incorrectly behaving within network.
        </t>
        <t>
An entity can also send only one fragment of a seemingly valid transfer and never send the remaining fragments, which will cause resources on the receiver to be wasted on transfer reassembly state.
The victim entity can either block packets from network peers or intentionally keep a short unfinished transfer timeout (see <xref target="sec-transfer-fragmentation"/>).
        </t>
        <t>
The keepalive mechanism can be abused to waste throughput within a network link which would otherwise be usable for bundle transmissions.
        </t>
      </section>
      <section anchor="sec-security-dtls-mandate">
        <name>Mandatory-to-Implement DTLS</name>
        <t>
Following IETF best current practice, DTLS is mandatory to implement for all UDPCL implementations but DTLS is optional to use for a any given transfer.
The recommended configuration of <xref target="sec-ext-starttls"/> is to always attempt DTLS, but entities are permitted to disable DTLS based on local configuration.
The configuration to enable or disable DTLS for an entity or a session is outside of the scope of this document.
The configuration to disable DTLS is different from the threat of DTLS stripping described in <xref target="sec-threat-tls-strip"/>.
        </t>
      </section>
      <section anchor="sec-security-tlsalt">
        <name>Alternate Uses of DTLS</name>
        <t>
This specification makes use of PKIX certificate validation and authentication within DTLS.
There are alternate uses of DTLS which are not necessarily incompatible with the security goals of this specification, but are outside of the scope of this document.
The following subsections give examples of alternate DTLS uses.
        </t>
        <section anchor="sec-security-tlsnoauth">
          <name>DTLS Without Authentication</name>
          <t> In environments where PKI is available but there are restrictions on the issuance of certificates (including the contents of certificates), it may be possible to make use of DTLS in a way which authenticates only the passive entity of a UDPCL transfer or which does not authenticate either entity.
Using DTLS in a way which does not successfully authenticate some claim of both peer entities of a UDPCL transfer is outside of the scope of this document but does have similar properties to the opportunistic security model of <xref target="RFC7435"/>.
          </t>
        </section>
        <section anchor="sec-security-tlsnopki">
          <name>Non-Certificate DTLS Use</name>
          <t>
In environments where PKI is unavailable, alternate uses of DTLS which do not require certificates such as pre-shared key (PSK) authentication <xref target="RFC5489"/> and the use of raw public keys <xref target="RFC7250"/> are available and can be used to ensure confidentiality within UDPCL.
Using non-PKI node authentication methods is outside of the scope of this document.
          </t>
        </section>
      </section>
      <section anchor="sec-security-xferid">
        <name>Predictability of Transfer IDs</name>
        <t>
The only requirement on Transfer IDs is that they are unique from the transmitting peer only.
The trivial algorithm of the first transfer starting at zero and later transfers incrementing by one causes absolutely predictable Transfer IDs.
Even when UDPCL is not DTLS secured and there is a on-path attacker altering UDPCL messages, there is no UDPCL feedback mechanism to interrupt or refuse a transfer so there is no benefit in having unpredictable Transfer IDs.
        </t>
      </section>
    </section>
    <section anchor="sec-iana">
      <name>IANA Considerations</name>
      <t>
Registration procedures referred to in this section are defined in <xref target="RFC8126"/>.
      </t>
      <section anchor="sec-iana-port">
        <name>Port Number</name>
        <t>
Within the port registry of <xref target="IANA-PORTS"/>, UDP port number 4556 has been previously assigned as the default port for the UDP convergence layer in <xref target="RFC7122"/>.
This assignment to UDPCL is unchanged, but the assignment reference is updated to this specification.
There is no UDPCL version indication on-the-wire but this specification is a superset of <xref target="RFC7122"/> and is fully backward compatible.
The related assignment for DCCP port 4556 (registered by <xref target="RFC7122"/>) is unchanged.
        </t>
        <table align="center">
          <thead>
            <tr>
              <th>Parameter</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Service Name:</td>
              <td>dtn-bundle</td>
            </tr>
            <tr>
              <td>Transport Protocol(s):</td>
              <td>UDP</td>
            </tr>
            <tr>
              <td>Assignee:</td>
              <td>IESG &lt;iesg@ietf.org&gt;</td>
            </tr>
            <tr>
              <td>Contact:</td>
              <td>IESG &lt;iesg@ietf.org&gt;</td>
            </tr>
            <tr>
              <td>Description:</td>
              <td>DTN Bundle UDP CL Protocol</td>
            </tr>
            <tr>
              <td>Reference:</td>
              <td>This specification.</td>
            </tr>
            <tr>
              <td>Port Number:</td>
              <td>4556</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="sec-iana-extension-types">
        <name>UDPCL Extension Types</name>
        <t>EDITOR NOTE: sub-registry to-be-created upon publication of this specification.</t>
        <t>
IANA will create, under the "Bundle Protocol" registry <xref target="IANA-BUNDLE"/>, a sub-registry titled "Bundle Protocol UDP Convergence-Layer Extension Types" and initialize it with the contents of <xref target="tab-iana-extension-types"/>.
For positive code points the registration procedure is Specification Required.
Negative code points are reserved for use on private networks for functions not published to the IANA.
        </t>
        <t>
Specifications of new extension types need to define the CBOR item structure of the extension data as well as the purpose and relationship of the new extension to existing session/transfer state within the baseline UDPCL sequencing.
Receiving entities will ignore items with unknown Extension ID, and that behavior needs to be considered by new extension types.
        </t>
        <t>
Expert(s) are encouraged to be biased towards approving registrations unless they are abusive, frivolous, or actively harmful (not merely aesthetically displeasing, or architecturally dubious).
        </t>
        <table align="center" anchor="tab-iana-extension-types">
          <name>Extension Type Codes</name>
          <thead>
            <tr>
              <th>Extension ID</th>
              <th>Name</th>
              <th>Item Type</th>
              <th>References</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>negative</td>
              <td>Private/Experimental Use</td>
              <td>any</td>
              <td>This specification.</td>
            </tr>
            <tr>
              <td>0</td>
              <td>Reserved</td>
              <td></td>
              <td>This specification.</td>
            </tr>
            <tr>
              <td>2</td>
              <td>Transfer</td>
              <td>array</td>
              <td><xref target="sec-ext-transfer"/> of this specification.</td>
            </tr>
            <tr>
              <td>5</td>
              <td>DTLS Initiation (STARTTLS)</td>
              <td>null</td>
              <td><xref target="sec-ext-starttls"/> of this specification.</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
    <section anchor="sec-doc-ack">
      <name>Acknowledgments</name>
      <t>
TBD
      </t>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="IANA-BUNDLE" target="https://www.iana.org/assignments/bundle/">
          <front>
            <title>Bundle Protocol</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="IANA-PORTS" target="https://www.iana.org/assignments/service-names-port-numbers/">
          <front>
            <title>Service Name and Transport Protocol Port Number Registry</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="IANA-IPv4-MCAST" target="https://www.iana.org/assignments/multicast-addresses/">
          <front>
            <title>IPv4 Multicast Address Space Registry</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="IANA-IPv6-MCAST" target="https://www.iana.org/assignments/ipv6-multicast-addresses/">
          <front>
            <title>IPv6 Multicast Address Space Registry</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0768.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1122.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5050.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5280.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6125.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6347.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6960.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7525.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8085.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8949.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dtn-bpbis.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dtn-tcpclv4.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2595.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4511.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4838.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5489.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6698.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7122.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7250.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7435.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7457.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7942.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8899.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dtn-bpsec.xml"/>
        <reference anchor="github-dtn-demo-agent" target="https://github.com/BSipos-RKF/dtn-demo-agent/">
          <front>
            <title>UDPCL Example Implementation</title>
            <author fullname="Brian Sipos" initials="B." surname="Sipos">
              <organization abbrev="RKF Engineering">
              RKF Engineering Solutions, LLC
              </organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="github-dtn-wireshark" target="https://github.com/BSipos-RKF/dtn-wireshark/">
          <front>
            <title>UDPCL Wireshark Dissector</title>
            <author fullname="Brian Sipos" initials="B." surname="Sipos">
              <organization abbrev="RKF Engineering">
              RKF Engineering Solutions, LLC
              </organization>
            </author>
            <date/>
          </front>
        </reference>
      </references>
    </references>
    <section>
      <name>Significant changes from RFC7122</name>
      <t>
The areas in which changes from <xref target="RFC7122"/> have been made to existing requirements:
      </t>
      <ul spacing="normal">
        <li>Made explicit references to UDP- and IP-related RFCs.</li>
        <li>Made more strict Keepalive requirements.</li>
        <li>Defined UDPCL security and made mandatory-to-implement.</li>
      </ul>
      <t>
The areas in which extensions from <xref target="RFC7122"/> have been made as new behaviors are:
      </t>
      <ul spacing="normal">
        <li>Added BPv7 bundle as a possible UDPCL payload.</li>
        <li>Added Extension Map message type and initial extension types.</li>
        <li>Defined semantics for UDPCL multicast addressing.</li>
      </ul>
    </section>
  </back>
</rfc>

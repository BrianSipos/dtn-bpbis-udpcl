<?xml version="1.0" encoding="UTF-8"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" consensus="true" docName="draft-sipos-dtn-udpcl-02" ipr="trust200902" submissionType="IETF" tocInclude="true" version="3" xml:lang="en">
  <front>
    <title abbrev="DTN UDPCLv2">
      Delay-Tolerant Networking UDP Convergence Layer Protocol Version 2
    </title>
    <seriesInfo name="Internet-Draft" value="draft-sipos-dtn-udpcl-02"/>
    <author fullname="Brian Sipos" initials="B." surname="Sipos">
      <organization abbrev="JHU/APL">The Johns Hopkins University Applied Physics Laboratory</organization>
      <address>
        <postal>
          <street>11100 Johns Hopkins Rd.</street>
          <city>Laurel</city>
          <region>MD</region>
          <code>20723</code>
          <country>United States of America</country>
        </postal>
        <email>brian.sipos+ietf@gmail.com</email>
      </address>
    </author>
    <date/>
    <area>Transport</area>
    <workgroup>Delay-Tolerant Networking</workgroup>
    <abstract>
      <t>
This document describes a UDP convergence layer (UDPCL) for Delay-Tolerant Networking (DTN).
This version of the UDPCL protocol clarifies requirements of RFC7122, adds discussion of multicast addressing, congestion signaling, and updates to the Bundle Protocol (BP) contents, encodings, and convergence layer requirements in BP version 7.
Specifically, the UDPCL uses CBOR-encoded BPv7 bundles as its service data unit being transported and provides an unreliable transport of such bundles.
This version of UDPCL also includes security and extensibility mechanisms.
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="sec-intro">
      <name>Introduction</name>
      <t>
This document describes the UDP convergence-layer protocol for Delay-Tolerant Networking (DTN).
DTN is an end-to-end architecture providing communications in and/or through highly stressed environments, including those with intermittent connectivity, long and/or variable delays, and high bit error rates.
More detailed descriptions of the rationale and capabilities of these networks can be found in "Delay-Tolerant Networking Architecture" <xref target="RFC4838"/>.
      </t>
      <t>
An important goal of the DTN architecture is to accommodate a wide range of networking technologies and environments.
The protocol used for DTN communications is the Bundle Protocol version 7 (BPv7) <xref target="RFC9171"/>, an application-layer protocol that is used to construct a store-and-forward overlay network.
BPv7 requires the services of a "convergence-layer adapter" (CLA) to send and receive bundles using the service of some "native" link, network, or Internet protocol.
This document describes one such convergence-layer adapter that uses the well-known User Datagram Protocol (UDP).
This convergence layer is referred to as UDP Convergence Layer (UDPCL).
For the remainder of this document, the abbreviation "BP" without the version suffix refers to BPv7.
      </t>
      <t>
The locations of the UDPCL and the Bundle Protocol in the Internet model protocol stack (described in <xref target="RFC1122"/>) are shown in <xref target="fig-udpcl-ip-stack"/>.
In particular, when BP is using UDP as its bearer with UDPCL as its convergence layer, both BP and UDPCL reside at the application layer of the Internet model.
      </t>
      <figure anchor="fig-udpcl-ip-stack">
        <name>The Locations of the Bundle Protocol and the UDP Convergence-Layer Protocol above the Internet Protocol Stack</name>
        <artwork align="center" type="ascii-art">
+-------------------------+
|     DTN Application     | -\
+-------------------------+   |
|  Bundle Protocol (BP)   |   -&gt; Application Layer
+-------------------------+   |
| UDP Conv. Layer (UDPCL) |   |
+-------------------------+   |
|     DTLS (optional)     | -/
+-------------------------+
|          UDP            | ---&gt; Transport Layer
+-------------------------+
|       IPv4/IPv6         | ---&gt; Network Layer
+-------------------------+
|   Link-Layer Protocol   | ---&gt; Link Layer
+-------------------------+
</artwork>
      </figure>
      <section>
        <name>Scope</name>
        <t>
This document describes the format of the protocol data units passed between entities participating in UDPCL communications.
This document does not address:
        </t>
        <ul spacing="normal">
          <li>
The format of protocol data units of the Bundle Protocol, as those are defined elsewhere in <xref target="RFC9171"/>.
This includes the concept of bundle fragmentation and bundle encapsulation.
The UDPCL transfers bundles as opaque data blocks.
          </li>
          <li>
Mechanisms for locating or identifying other bundle entities (peers) within a network or across an internet.
The mapping of a Node ID to a potential convergence layer (CL) protocol and network address is left to implementation and configuration of the BP Agent (BPA) and its various potential routing strategies, as is the mapping of a DNS name and/or address to a choice of an end-entity certificate to authenticate a node to its peers.
          </li>
          <li>
Logic for routing bundles along a path toward a bundle's endpoint.
This CL protocol is involved only in transporting bundles between adjacent entities in a routing sequence.
          </li>
          <li>
Logic for performing rate control and congestion control of bundle transfers, both incoming and outgoing from a UDPCL entity.
The signaling defined in <xref target="sec-ext-ecn-counts"/> and <xref target="sec-pathchar-cc"/> can support a congestion control mechanism, but it is an implementation matter to choose and configure such a mechanism.
          </li>
          <li>
Policies or mechanisms for issuing Public Key Infrastructure Using X.509 (PKIX) certificates; provisioning, deploying, or accessing certificates and private keys; deploying or accessing certificate revocation lists (CRLs); or configuring security parameters on an individual entity or across a network.
          </li>
          <li>
Uses of Datagram Transport Layer Security (DTLS) which are not based on PKIX certificate authentication (see <xref target="sec-security-tlsnopki"/>) or in which authentication of both entities is not possible (see <xref target="sec-security-tlsnoauth"/>).
          </li>
        </ul>
        <t>
Any UDPCL implementation requires a BP agent to perform those above listed functions in order to perform end-to-end bundle delivery.
        </t>
      </section>
      <section>
        <name>Use of CDDL</name>
        <t>
This document defines CBOR structure using the Concise Data Definition Language (CDDL) of <xref target="RFC8610"/>.
The entire CDDL structure can be extracted from the XML version of this document using the XPath expression:
        </t>
        <sourcecode>'//sourcecode[@type="cddl"]'</sourcecode>
        <t>
The following initial fragment defines the top-level symbols of this document's CDDL.
        </t>
        <sourcecode type="cddl">
start = udpcl-ext-map
        </sourcecode>
      </section>
      <section>
        <name>Requirements Language</name>
        <t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as shown here.
        </t>
      </section>
      <section anchor="sec-term-defs">
        <name>Definitions Specific to the UDPCL Protocol</name>
        <t>
This section contains definitions specific to the UDPCL protocol.
        </t>
        <dl newline="false" spacing="normal">
          <dt>UDPCL Entity:</dt>
          <dd>
            <t>
This is the notional UDPCL application that initiates UDPCL transfers.
This design, implementation, configuration, and specific behavior of such an entity is outside of the scope of this document.
However, the concept of an entity has utility within the scope of this document as the container and initiator of transfers.
The relationship between a UDPCL entity and UDPCL sessions is defined as follows:
            </t>
            <ul spacing="normal">
              <li>
A UDPCL Entity <bcp14>MAY</bcp14> actively perform any number of transfers and <bcp14>SHOULD</bcp14> do so whenever the entity has a bundle to forward to another entity in the network.
              </li>
              <li>
A UDPCL Entity <bcp14>MAY</bcp14> support zero or more passive listening elements that listen for transfers from other entities in the network, including non-unicast transfers.
              </li>
            </ul>
            <t>
These relationships are illustrated in <xref target="fig-entity-transfer-relations"/>.
For the remainder of this document, the term "entity" without the prefix "UDPCL" refers to a UDPCL entity.
            </t>
          </dd>
          <dt>UDP Conversation:</dt>
          <dd>
This refers to datagrams exchanged between two network peers, with each peer identified by a (unicast IP address, UDP port) tuple.
Because UDP is connectionless, there is no notion of a conversation being "opened" or "closed" and some conversations are uni-directional.
          </dd>
          <dt>Transfer:</dt>
          <dd>
This refers to the procedures and mechanisms for conveyance of an individual bundle from one entity to one or more destinations.
This version of UDPCL includes a segmentation mechanism to allow transfers which are larger than the allowable UDP datagram size.
          </dd>
          <dt>Transmit:</dt>
          <dd>
This refers to a transfer outgoing from an entity as seen from that transmitting entity.
          </dd>
          <dt>Receive:</dt>
          <dd>
This refers to a transfer incoming to an entity as seen from that receiving entity.
          </dd>
        </dl>
        <figure anchor="fig-entity-transfer-relations">
          <name>The relationships between UDPCL entities</name>
          <artwork align="center" type="ascii-art">
+----------------------------------------+
|              UDPCL Entity              |
|                                        |      +----------------+
|   +--------------------------------+   |      |                |-+
|   | Actively Initiated Transfer #1 |---------&gt;| Other          | |
|   +--------------------------------+   |      | UDPCL Entity's | |
|                  ...                   |      | Passive        | |
|   +--------------------------------+   |      | Listener       | |
|   | Actively Initiated Transfer #n |---------&gt;|                | |
|   |                                |          |                | |
|   |         Sender Listen          |&lt;---------|                | |
|   +--------------------------------+   |      +----------------+ |
|                                        |       +-----------------+
|      +---------------------------+     |
|      | +---------------------------+   |      +----------------+
|      | | Optional Passive          |   |      |                |-+
|      +-| Listener(s)               |&lt;---------+ Other          | |
|        +---------------------------+   |      | UDPCL Entity's | |
|                                 ^      |      | Active         | |
|                                 |      |      | Initiator(s)   | |
|                                 +-------------|                | |
+----------------------------------------+      +----------------+ |
                                                 +-----------------+
</artwork>
        </figure>
      </section>
    </section>
    <section anchor="sec-prococol">
      <name>General Protocol Description</name>
      <t>
The service of this protocol is the transmission of DTN bundles via the User Datagram Protocol (UDP).
This document specifies the optional segmentation of bundles, procedures for DTLS setup and teardown, and a set of messages and entity requirements.
The general operation of the protocol is as follows.
      </t>
      <t>
Fundamentally, the UDPCL is a (logically) unidirectional "transmit and forget" protocol which itself maintains no long-term state and provides no feedback from the receiver to the transmitter.
The only long-term state related to UDPCL is used by DTLS in its session keeping (which is bound to a UDP conversation).
An entity receiving a bundle from a particular source address-and-port does not imply that the transmitter is willing to accept bundle transfers on that same address-and-port.
It is the obligation of a BP agent and its routing schemes to determine a bundle return path (if such a path even exists).
      </t>
      <section anchor="sec-cl-services">
        <name>Convergence Layer Services</name>
        <t>
This version of the UDPCL provides the following services to support the over-laying Bundle Protocol agent.
In all cases, this is not an API definition but a logical description of how the CL can interact with the BP agent.
Each of these interactions can be associated with any number of additional metadata items as necessary to support the operation of the CL or BP agent.
        </t>
        <dl newline="false" spacing="normal">
          <dt>Begin Transmission:</dt>
          <dd>
The principal purpose of the UDPCL is to allow a BP agent to transmit bundle data to one or more other entities.
The receiver of each transfer is identified by an (destination) IPv4 or IPv6 address, a UDP port number, and an optional local interface identifier (see <xref target="sec-operation"/> for details).
The CL does not necessarily perform any transmission queueing (see <xref target="sec-policy-cc"/>), but might block while transmissions are being processed at the UDP layer.
Any queueing of transmissions is the obligation of the BP agent.
          </dd>
          <dt>Transmission Started:</dt>
          <dd>
The UDPCL entity indicates to the BP agent when a bundle transmission begins sending UDP datagrams.
Once started, there is no notion of a UDPCL transmission failure; a BP agent has to rely on bundle-level status reporting to track bundle progress through the network.
Because of potential queueing or DTLS setup time, this can be delayed from the BP agent providing the bundle-to-transmit.
          </dd>
          <dt>Transmission Finished:</dt>
          <dd>
The UDPCL entity indicates to the BP agent when a bundle has been fully transmitted.
This is not a positive indication that any next-hop receiver has either received or processed the transfer.
          </dd>
          <dt>Reception Started:</dt>
          <dd>
The UDPCL entity indicates to the BP agent when a bundle transfer has begun, which can include information about the total size of a segmented transfer.
          </dd>
          <dt>Reception Success:</dt>
          <dd>
The UDPCL entity indicates to the BP agent when a bundle has been fully transferred from a peer entity.
The transmitter of each transfer is identified by a (source) IP address, a UDP port number, and an optional local interface identifier (see <xref target="sec-operation"/> for details).
          </dd>
          <dt>Reception Failure:</dt>
          <dd>
The UDPCL entity indicates to the BP agent on certain reasons for reception failure, notably upon an unfinished transfer timeout (see <xref target="sec-ext-transfer"/>).
          </dd>
          <dt>Attempt DTLS Session:</dt>
          <dd>
The UDPCL allows a BP agent to preemptively attempt to establish a DTLS session with a peer entity (see <xref target="sec-ext-starttls"/> and <xref target="sec-udpcl-security"/>).
Each session attempt can send a different set of session negotiation parameters as directed by the BP agent.
          </dd>
          <dt>Close DTLS Session:</dt>
          <dd>
The UDPCL allows a BP agent to preemptively close an established DTLS session with a peer entity.
The closure request is on a per-session basis.
          </dd>
          <dt>DTLS Session State Changed:</dt>
          <dd>
The UDPCL entity indicates to the BP agent when a DTLS session state changes.
The possible DTLS session states are defined in <xref target="RFC9147"/>.
          </dd>
          <dt>Begin Sender Listen:</dt>
          <dd>
The UDPCL allows a BP agent to indicate when packets on a particular address-and-port is listened for (see <xref target="sec-ext-sender-listen"/>).
The Sender Listen interval is configurable for each peer address-and-port.
          </dd>
          <dt>End Sender Listen:</dt>
          <dd>
The UDPCL allows a BP agent to indicate when packets on a particular address-and-port are no longer be accepted.
          </dd>
          <dt>Sender Listen Received:</dt>
          <dd>
The UDPCL entity indicates to the BP agent when a Sender Listen extension has been received from a peer.
The Sender Node ID, if present, is part of this indication.
          </dd>
        </dl>
      </section>
      <section anchor="sec-pkix-env">
        <name>PKIX Environments and CA Policy</name>
        <t>
This specification gives requirements about how to use PKIX certificates issued by a Certificate Authority (CA), but does not define any mechanisms for how those certificates come to be.
The UDPCL uses the exact same mechanisms and makes the same assumptions as TCPCL in <xref section="3.4" target="RFC9174"/>.
        </t>
      </section>
      <section anchor="sec-policy-udp-convo">
        <name>UDP Conversation Stability</name>
        <t>
Unlike the loose UDPCL definition in <xref target="RFC7122"/>, the requirements in this document ensure that traffic between two peers with stable IP addresses also use stable UDP port numbers.
This enables the UDPCL to be more compatible with network address translation (NAT) middleboxes and, where necessary, enables the UDPCL to be used along with protocols such as Session Traversal Utilities for NAT (STUN) <xref target="RFC8489"/> and Interactive Connectivity Establishment (ICE) <xref target="RFC8445"/>.
        </t>
        <t>
There is a trade-off between stability of UDP conversations and a possible need to protect from off-path data injection, as described in <xref target="sec-threat-injection"/>, so the conversation long-term stability (in <xref target="sec-ip-header"/> and <xref target="sec-udp-header"/>) is recommended while specific cases of short-term consistency <xref target="sec-ext-transfer"/>, <xref target="sec-ext-sender-listen"/>, and <xref target="sec-ext-peer-probe"/> are required.
        </t>
      </section>
      <section anchor="sec-policy-pathchar">
        <name>Path Characterization</name>
        <t>
The earlier UDPCL definition in <xref target="RFC7122"/> assumed that BP node operators had deep visibility into the IP networks over which bundles would be transferred, specifically that the IP paths between UDPCL sender and receiver had well-characterized parameters for: path maximum transmit unit (PMTU), one-way delay time, one-way throughput limit, and packet loss statistics (both due to congestion and to link errors).
        </t>
        <t>
In situations where node operators do not have prior information about those parameters, this version of the UDPCL supports mechanisms to measure or estimate them.
These mechanisms are defined in detail under <xref target="sec-pathchar"/>.
        </t>
      </section>
      <section anchor="sec-policy-fragmentation">
        <name>Fragmentation Policies</name>
        <t>
It is a implementation matter for a sending entity to determine the PMTU to be used as a target upper-bound UDP datagram size.
        </t>
        <t>
The priority order of fragmentation is the following:
        </t>
        <ol>
          <li>
When possible, bundles too large to fit in one PMTU-sized packet <bcp14>MAY</bcp14> be fragmented at the BP layer.
Bundle payload fragmentation does not help a large bundle if extension blocks are a major contributor to bundle size, so in some circumstances BP layer fragmentation will not reduce the bundle size sufficiently.
It is outside the scope of UDPCL to manage BP agent fragmentation policies; encoded bundles are received from the BP agent either already fragmented or not.
          </li>
          <li>
When a PMTU is available to a peer, bundles too large to fit in one PMTU-sized packet <bcp14>SHALL</bcp14> be segmented as a UDPCL transfer (see <xref target="sec-transfer"/>).
Segmentation at this level treats bundle transfers as opaque data, so it is independent of bundle block sizes or counts.
When a PMTU is available, IPv4 packets sent by a UDPCL entity <bcp14>SHOULD</bcp14> have the DF bit set to allow detection of PMTU issues.
          </li>
          <li>
All IPv6 packets and all IPv4 packets which do not have the DF bit set which are larger than the link MTU will be fragmented by the transmitting entity to fit within one link MTU.
Because of the issues listed in <xref section="3.2" target="RFC8085"/> and <xref target="RFC8900"/>, it is best to avoid IP fragmentation as much as possible.
          </li>
        </ol>
        <t>
A UDPCL entity <bcp14>SHOULD NOT</bcp14> proactively drop an outgoing transfer due to datagram size.
If intermediate network nodes drop IP packets it is an implementation matter to receive network feedback (e.g. ICMP <em>Fragmentation Needed</em> of <xref target="RFC792"/> or ICMPv6 <em>Packet Too Big</em> of <xref section="3.2" target="RFC4443"/>).
The UDPCL itself provides no transfer acknowledgement mechanism or other protocol-level reception feedback other than the optional <xref format="title" target="sec-plpmtud"/> procedure, which is why an accurate PMTU for a peer is critical information.
        </t>
      </section>
      <section anchor="sec-policy-ec">
        <name>Error Checking Policies</name>
        <t>
The core Bundle Protocol specification assumes that bundles are transferring over an erasure channel, i.e., a channel that either delivers packets correctly or not at all.
        </t>
        <t>
A UDP transmitter <bcp14>SHALL NOT</bcp14> disable UDP checksums.
A UDP receiver <bcp14>SHALL NOT</bcp14> disable the checking of received UDP checksums.
        </t>
        <t>
Even when UDP checksums are enabled, a small probability of UDP packet corruption remains.
In some environments, it could be acceptable for a BPA to occasionally receive corrupted input for some blocks.
In general, however, a BPA is RECOMMENDED to ensure the a bundle's blocks are covered by a CRC so that next-hop receivers can verify the block contents.
        </t>
      </section>
      <section anchor="sec-policy-cc">
        <name>Congestion Control Policies</name>
        <t>
The applications using UDPCL for bundle transport <bcp14>SHALL</bcp14> conform to the congestion control requirements of <xref section="3.1" target="RFC8085"/>.
The application <bcp14>SHALL</bcp14> either perform active congestion control of bundles or behave as the Low Data-Volume application as defined in <xref section="3.1.3" target="RFC8085"/>.
        </t>
        <t>
When nodes have bidirectional IP capability with a peer, the ECN marking and feedback mechanism of <xref target="sec-pathchar-cc"/> can be used to provide Active Queue Management (AQM) of UDP traffic (and thus BP traffic) to the peer providing feedback.
It is an implementation matter to ensure that traffic patterns which require UDPCL queuing and rate control are paired with a UDPCL entity capable of AQM and peers which provide requisite ECN feedback.
        </t>
        <t>
When nodes have bidirectional BP transfer capability, the bundle deletion reason code "traffic pared" can be used by a receiving agent to signal to the bundle source application that throttling of bundles along that BP path needs to occur.
        </t>
      </section>
    </section>
    <section anchor="sec-operation">
      <name>UDPCL Operation</name>
      <t>
This section defines the UDPCL protocol and its interactions with under-layers (IP and UDP) and over-layers (BP), as illustrated in <xref target="fig-udpcl-ip-stack"/>.
The section is organized from the network layer up toward the BP layer.
It also discusses behavior within the UDPCL layer, which is illustrated in <xref target="fig-udpcl-sublayers"/>.
      </t>
      <figure anchor="fig-udpcl-sublayers">
        <name>Breakdown of sub-layers within the UDPCL</name>
        <artwork align="center" type="ascii-art">
+-------------------------------------------+
| Identified Transfer | Extension Signaling | &lt;- Sequencing /
+-------------------------------------------+      segmentation
 \                                          /
  ------                   -----------------
        \                 /
+-------------------------------------------+
| Bundle | Extension Map |  ...   | Padding | &lt;- Messaging
+-------------------------------------------+
|                UDPCL Packet               | &lt;- Packetization
+-------------------------------------------+
</artwork>
      </figure>
      <section anchor="sec-ip-header">
        <name>IP Header</name>
        <t>
The earlier UDPCL specification in <xref target="RFC7122"/> did not include guidance on IP addressing, interface sourcing, or potential use of multicast, though the architecture of <xref target="RFC4838"/> explicitly includes multicast and anycast as expected network modes.
        </t>
        <t>
For each forwarding transfer the BP agent determines the mapping from destination EID to next-hop CL parameters, including next-hop destination address and source interface.
Some EIDs represent singleton destinations and others non-singleton destinations as defined in <xref section="4.2.5.1" target="RFC9171"/>.
The singleton-ness of an EID does not necessarily correspond with the unicast-ness of its forwarding, as some bundle routing schemes involve attempting multiple parallel paths to a singleton endpoint and some involve forwarding non-singleton-destination traffic to known individual BP neighbors along unicast paths.
        </t>
        <t>
For unicast transfers to a single node, the destination address <bcp14>SHALL</bcp14> be a non-multicast IPv4 or IPv6 address (which includes link-local addresses).
For unicast transfers, the source interface address <bcp14>MAY</bcp14> be supplied by the BP agent or otherwise determined by the operating system IP routing.
When performing unicast transfers, a UDPCL entity <bcp14>SHOULD</bcp14> require DTLS use (see <xref target="sec-udpcl-security"/>) or restrict the network to one protected by IPsec or some other under-layer security mechanism (e.g., a virtual private network).
        </t>
        <t>
For multicast transfers to any number of nodes, the destination address <bcp14>SHALL</bcp14> be a multicast IPv4 <xref target="IANA-IPv4-MCAST"/> or IPv6 <xref target="IANA-IPv6-MCAST"/> address.
The well-known multicast addresses defined in <xref target="sec-iana-ip-mcast"/> <bcp14>SHALL</bcp14> be used as a default in the absence of any network-specific configuration. 
For multicast transfers, the source interface address MUST be supplied by the BP agent rather than inferred by the UDPCL entity.
For multicast transfers the UDPCL does not define any security mechanism.
        </t>
        <t>
When supported by an implementation, the UDPCL <bcp14>SHOULD</bcp14> accept and provide information on the local interface from which a transmission is sent or to which a reception was received.
For IPv6 this corresponds with the <tt>IPV6_PKTINFO</tt> ancillary data API of <xref section="6.1" target="RFC3542"/>; for IPv4 this is an implementation-specific detail supported by <tt>IP_PKTINFO</tt> ancillary data on some operating systems.
Identifying an interface for transmission or reception allows a BPA to provide fine-grained control and visibility when UDPCL is used for IP multicast or when link-local addressing is in use.
        </t>
        <t>
The IPv4 header bit <em>don't fragment</em> (DF) is used as discussed in <xref target="sec-policy-fragmentation"/>.
        </t>
        <t>
The IPv4 and IPv6 header field for Explicit Congestion Notification (ECN) is used as discussed in <xref target="sec-policy-cc"/> and <xref target="sec-pathchar-cc"/>.
        </t>
      </section>
      <section anchor="sec-udp-header">
        <name>UDP Header</name>
        <t>
UDP port number 4556 has been assigned by IANA <xref target="IANA-PORTS"/> as the Registered Port number for the UDPCL and <bcp14>SHALL</bcp14> be used as a default for both source and destination.
Other source or destination port numbers <bcp14>MAY</bcp14> be used per local configuration.
Determining a passive entity's destination port number (if different from the registered UDPCL port number) is up to the implementation.
        </t>
        <t>
If the default source port is not used, typically an operating system assigned number in the UDP Ephemeral range (49152-65535) is used.
For repeated messaging to the same destination address-and-port, the active entity <bcp14>SHOULD</bcp14> reuse the same source address-and-port.
For feedback messaging, the passive entity <bcp14>SHALL</bcp14> respond to the same address-and-port that solicited the feedback and use the same source address-and-port which was listed on.
Reusing source address-and-port allows simplifies network monitoring and analysis and also enables bi-directional messaging as defined in <xref target="sec-ext-sender-listen"/>, <xref target="sec-plpmtud"/>, and <xref target="sec-pathchar-cc"/>.
          </t>
      </section>
      <section anchor="sec-packet">
        <name>UDPCL Packets</name>
        <t>
The lowest layer of UDPCL communication are individual-datagram packets.
To exchange UDPCL data, an active entity <bcp14>SHALL</bcp14> transmit a UDP datagram to a listening passive entity in accordance with <xref target="RFC0768"/>, typically by using the services provided by the operating system.
For backward compatibility with <xref target="RFC7122"/>, UDPCL has no explicit message type identifier.
        </t>
        <t>
Each UDP datagram <bcp14>SHALL</bcp14> contain one or more UDPCL message as defined in <xref target="sec-udpcl-message"/>.
Each type of message defines additional restrictions on how it can be used in a packet.
        </t>
        <t>
The following are special cases of UDPCL packet uses.
        </t>
        <dl newline="false" spacing="normal">
          <dt>Unframed Transfer:</dt>
          <dd>
An unframed transfer packet <bcp14>SHALL</bcp14> consist of a single encoded BPv6 or BPv7 bundle with no padding.
This provides backward compatibility with <xref target="RFC7122"/> and a allows a trivial use of UDPCL which is just embedding an encoded bundle in a UDP datagram.
          </dd>
          <dt>Keepalive:</dt>
          <dd>
A keepalive packet <bcp14>SHALL</bcp14> consist of exactly four octets of padding with no preceding message.
This behavior maintains backward compatibility with <xref target="RFC7122"/>.
          </dd>
          <dt>DTLS Record:</dt>
          <dd>
            <t>
In addition to the UDPCL-specific messaging, immediately after a DTLS Initiation (see <xref target="sec-ext-starttls"/>) the DTLS handshake sequence will begin.
Packets with a leading octet value of 0x16 <bcp14>SHALL</bcp14> be treated as a DTLS handshake record in accordance with <xref section="4.1" target="RFC9147"/>.
            </t>
            <t>
If the datagram with the DTLS Initiation extension is not received by an entity, the entity <bcp14>SHOULD</bcp14> still detect the DTLS handshake records and start the handshake sequence at that point.
Packets with a leading octet value of 0x14--0x1A or 0x20--0x3F <bcp14>SHALL</bcp14> be treated as a DTLS sequencing failure; DTLS non-handshake records <bcp14>SHOULD</bcp14> never be seen by the UDPCL messaging layer.
            </t>
          </dd>
        </dl>
        <section anchor="sec-packet-redundancy">
          <name>Redundant Transmission</name>
          <t>
Because the UDPCL uses unreliable UDP as its transmission layer, an entity with information about the loss characteristics of the path to a peer entity can intentionally perform duplicate transmissions to improve the chances that the packet, message, or whole transfer will arrive at the receiver.
It is an implementation matter to determine when to perform redundant transmission, and could be based on the interface, peer network or address, or properties of the UDPCL packet itself.
          </t>
          <t>
The number of duplicate transmissions for a packet is referred to as its Redundancy Factor.
A Redundancy Factor of one means to perform no duplicate transmission.
A larger Redundancy Factor will result in more network resources used (and possibly wasted).
          </t>
          <t>
The time interval between original and each duplicate transmission is referred to as its Redundancy Delay.
A larger Redundancy Delay will result in more entity resources used keeping packet contents in memory for retransmission.
To avoid a receiver mishandling redundant packets containing Transfer items (see <xref target="sec-transfer-segmentation"/>) the Redundancy Delay <bcp14>SHOULD</bcp14> be no longer than the receiver's transfer timeout, if known, or one minute (60 seconds).
          </t>
          <t>
For paths where losses over time are bursty, a low redundancy factor but high redundancy delay will ensure that the duplicated packets are transmitted over a longer span of time and (hopefully) do not have a correlated probability of loss.
          </t>
          <t>
To avoid unnecessary processing on the receiver's BP Agent, when redundant transmission is used the <xref target="sec-transfer">identified transfer</xref> mechanism <bcp14>SHALL</bcp14> be used even for single-segment transfers.
This allows the UDPCL entity can discard any duplicate receptions before they reach the BP Agent.
If redundant transmission is used with an unframed transfer the UDPCL has no ability to discard any duplicate receptions and all duplicates will be seen by the receiving BP Agent.
          </t>
        </section>
      </section>
      <section anchor="sec-udpcl-message">
        <name>UDPCL Messages</name>
        <t>
The middle layer of UDPCL communication are unframed, but self-delimited, messages.
Specific message types <bcp14>MAY</bcp14> be concatenated together into a single packet, each message type indicates any restrictions on how it can be used within a packet.
        </t>
        <t>
For backward compatibility with <xref target="RFC7122"/>, UDPCL has no explicit message type identifier.
The message type is inferred by the inspecting the data contents according to the following rules:
        </t>
        <dl>
          <dt>Bundle:</dt>
          <dd>
            <t>
When sent outside of an explicit <xref target="sec-transfer">identified transfer</xref> an encoded bundle is treated as a separate message type.
This is for compatibility with <xref target="RFC7122"/> but comes at the expense of the UDPCL not being able to de-duplicate any <xref target="sec-packet-redundancy">redundant transfers</xref>.
            </t>
            <dl>
              <dt>BPv6 Bundle:</dt>
              <dd>
All encoded BP version 6 bundles begin with the version identifier octet 0x06 in accordance with <xref target="RFC5050"/>.
A message with a leading octet value of 0x06 <bcp14>SHALL</bcp14> be treated as a BPv6 bundle.
Multiple BPv6 Bundles <bcp14>SHOULD NOT</bcp14> be present in one UDPCL packet to maintain compatibility with <xref target="RFC7122"/>.
              </dd>
              <dt>BPv7 Bundle:</dt>
              <dd>
                <t>
All encoded BP version 7 bundles begin with a CBOR array head in accordance with <xref target="RFC9171"/>.
A message with a leading octet value indicating CBOR array (major type 4) <bcp14>SHALL</bcp14> be treated as a BPv7 bundle.
                </t>
                <t>
BPv7 bundles transmitted via UDPCL <bcp14>SHALL NOT</bcp14> include any leading CBOR tag.
If the BP agent provides bundles with such tags the transmitting UDPCL entity <bcp14>SHALL</bcp14> remove them.
                </t>
              </dd>
            </dl>
          </dd>
          <dt>Extension Map:</dt>
          <dd>
All UDPCL extensions <bcp14>SHALL</bcp14> be contained in a CBOR map in accordance with the definitions of <xref target="sec-udpcl-extension"/>.
The encoded Extension Map <bcp14>SHALL NOT</bcp14> have any CBOR tags.
A message with a leading octet value indicating CBOR map (major type 5) <bcp14>SHALL</bcp14> be treated as an Extension Map.
          </dd>
          <dt>Padding:</dt>
          <dd>
            <t>
Padding data <bcp14>SHALL</bcp14> be a sequence of octets all with value 0x00.
A message with a leading octet value of 0x00 <bcp14>SHALL</bcp14> be treated as padding.
            </t>
            <t>
Padding is used to ensure a UDP datagram is exactly a desired size.
Because padding has no intrinsic length indication, if present it <bcp14>SHALL</bcp14> be the last contents of any UDPCL packet.
A receiving UDPCL entity <bcp14>SHALL</bcp14> ignore all padding, including any trailing non-zero octets.
            </t>
          </dd>
        </dl>
        <t>
A summary of how a receiving UDPCL entity can interpret the first octet of a UDPCL packet is listed in <xref target="tab-message-first-octet"/>.
When inspecting using CBOR major types, the range of values is caused by the CBOR head encoding of <xref target="RFC8949"/>.
        </t>
        <table align="center" anchor="tab-message-first-octet">
          <name>First-Octet Contents</name>
          <thead>
            <tr>
              <th>Octet Value</th>
              <th>Message Content</th>
              <th>Message Extent</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0x00</td>
              <td>Padding</td>
              <td>Remainder of packet</td>
            </tr>
            <tr>
              <td>0x06</td>
              <td>BPv6 Bundle</td>
              <td>Remainder of packet (to be decoded by BPA)</td>
            </tr>
            <tr>
              <td><t>0x14--0x1A or</t><t>0x20--0x3F</t></td>
              <td>DTLS Record</td>
              <td>Remainder of packet</td>
            </tr>
            <tr>
              <td>0x80--0x9F</td>
              <td>BPv7 Bundle (CBOR array)</td>
              <td>Remainder of packet (to be decoded by BPA)</td>
            </tr>
            <tr>
              <td>0xA0--0xBF</td>
              <td>Extension Map (CBOR map)</td>
              <td>End of map item, possibly followed by other map or padding</td>
            </tr>
            <tr>
              <td>others</td>
              <td>unused</td>
              <td/>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="sec-udpcl-extension">
        <name>UDPCL Extension Items</name>
        <t>
Extensions to UDPCL are encoded per-datagram in a single CBOR map as defined in <xref target="sec-udpcl-message"/>.
Each UDPCL extension item <bcp14>SHALL</bcp14> be identified by a unique Extension ID used as a key in the Extension Map.
Extension ID values <bcp14>SHALL</bcp14> be a CBOR <tt>int</tt> item which fits within a signed 16-bit integer.
Extension ID assignments are listed in <xref target="sec-iana-extension-types"/>.
        </t>
        <t>
Unless prohibited by particular extension type requirements, a single Extension Map <bcp14>MAY</bcp14> contain any combination of extension items.
Receivers <bcp14>SHALL</bcp14> ignore extension items with unknown Extension ID and continue to process known extension items.
        </t>
        <figure anchor="fig-udpcl-ext-map">
          <name>Extension Map structure CDDL</name>
          <sourcecode type="cddl">
; Map structure requiring non-zero-int keys.
; CDDL cannot enforce type-specific requirements about other items
; being present (or not present) in the same map.
udpcl-ext-map = $udpcl-ext-map .within udpcl-ext-map-structure
$udpcl-ext-map = {
    + $$udpcl-ext-item
}
udpcl-ext-map-structure = {
    + ext-key =&gt; any
}
ext-key = ((-32768 .. 32767) .within int) .ne 0
          </sourcecode>
        </figure>
        <t>
The following subsections define the initial UDPCL extension types.
        </t>
        <section anchor="sec-ext-support">
          <name>Extension Support</name>
          <t>
This extension allows an entity to signal its support for receiving specific UDPCL extension types.
          </t>
          <t>
The Extension Support value <bcp14>SHALL</bcp14> be a CBOR array of <tt>int</tt> items.
Each item <bcp14>SHALL</bcp14> represent an extension type code which is able to be handled by the entity sending the Extension Support.
          </t>
          <t>
The minimum set of Extension Support <bcp14>SHOULD</bcp14> contain values 1 through 8 inclusive, which are the extension types defined in this document.
          </t>
          <figure>
            <name>Extension Support CDDL</name>
            <sourcecode type="cddl">
$$udpcl-ext-item //= (
    1: [ + ext-key ]
)
            </sourcecode>
          </figure>
          <t>
This extension type is expected to be used along with <xref format="title" target="sec-ext-sender-listen"/> for announcing presence to (potential) peer entities.
          </t>
          <t>
If an entity receives an extension type which it cannot handle, that entity <bcp14>MAY</bcp14> send an Extension Support item in response.
The enveloping UDPCL packet <bcp14>SHALL</bcp14> use the source address-and-port that sent the unhandled extension type as the destination of the packet.
          </t>
        </section>
        <section anchor="sec-ext-transfer">
          <name>Transfer</name>
          <t>
This extension item allows CL-layer segmentation of bundle transfers as defined in <xref target="sec-transfer"/>.
          </t>
          <t>
The Transfer value <bcp14>SHALL</bcp14> be an untagged CBOR array of two or four items.
The items are defined in the following order:
          </t>
          <dl>
            <dt>Transfer ID:</dt>
            <dd>
This field <bcp14>SHALL</bcp14> be a CBOR <tt>uint</tt> item no larger than 32-bits, which is used to correlate multiple segments.
            </dd>
            <dt>Total Length:</dt>
            <dd>
This optional field <bcp14>SHALL</bcp14> be a CBOR <tt>uint</tt> item no larger than 32-bits, which is used to indicate the total length (in octets) of the transfer.
If multiple Transfer items for the same Transfer ID are received with differing Total Length values, the receiver <bcp14>SHALL</bcp14> treat the transfer as being malformed and refuse to handle any further segments associated with the transfer.
If a transfer requires only a single segment, this field <bcp14>SHALL</bcp14> be omitted and the total length treated as the size of the Segment Data.
            </dd>
            <dt>Segment Offset:</dt>
            <dd>
This optional field <bcp14>SHALL</bcp14> be a CBOR <tt>uint</tt> item no larger than 32-bits, which is used to indicate the offset (in octets) into the transfer for the start of this segment.
If a transfer requires only a single segment, this field <bcp14>SHALL</bcp14> be omitted and the segment offset treated as zero.
            </dd>
            <dt>Segment Data:</dt>
            <dd>
This field <bcp14>SHALL</bcp14> be a CBOR bstr item no larger than 2^32-1 octets, in which the segment data is contained.
The <tt>bstr</tt> itself indicates the length of the segment data.
            </dd>
          </dl>
          <figure>
            <name>Transfer CDDL</name>
            <sourcecode type="cddl">
$$udpcl-ext-item //= (
    2: [
        transfer-id: uint .size 4,
        ?(
            total-length: uint .size 4,
            segment-offset: uint .size 4,
        ),
        segment-data: bstr,
    ]
)
              </sourcecode>
          </figure>
          <t>
Multiple Transfer items <bcp14>MAY</bcp14> be present in the same UDPCL packet by concatenating multiple Extension Map into one packet.
          </t>
          <t>
A transmitting entity <bcp14>SHALL</bcp14> use the same source and destination address-and-port for all UDPCL packets comprising a single segmented transfer.
This is more strict than the requirements of <xref target="sec-udp-header"/> to ensure consistent reassembly behavior in <xref target="sec-transfer-segmentation"/>.
          </t>
        </section>
        <section anchor="sec-ext-sender-listen">
          <name>Sender Listen</name>
          <t>
This extension item indicates that the transmitter is listening for UDPCL packets on the source address-and-port used to transmit the message containing this extension item.
This is different from simply listening on a UDP port (either the default or any other) when the entity is behind a NAT or firewall which will not allow unsolicited UDP/IP datagrams.
Although the packet containing this extension is not retransmitted, the time interval is finite and the extension is sent repeatedly while the transmitter continues to listen for packets.
There is no positive indication that packets are no longer accepted; the Sender Listen just stops being transmitted.
          </t>
          <t>
The Sender Listen value <bcp14>SHALL</bcp14> be an untagged <tt>uint</tt> value representing the interval of time (in milliseconds) that the entity is willing to accept UDPCL packets on the source address-and-port used for the associated transmitted message.
After transmitting a Sender Listen, the entity <bcp14>SHALL</bcp14> listen for and accept datagrams on the source address-and-port used for the associated transmitted message.
As long as the entity is still willing to accept packets, at the end of one accept interval the entity <bcp14>SHALL</bcp14> transmit another Sender Listen item.
This repetition continues until the entity is no longer willing to listen for packets.
          </t>
          <t>
A receiving entity <bcp14>SHOULD</bcp14> treat a peer as no longer listening after an implementation-defined timeout since the last received Sender Listen item.
A RECOMMENDED Sender Listen timeout is three (3) times the associated time duration; this allows a single dropped datagram to not interrupt a continuous sequence.
          </t>
          <figure>
            <name>Sender Listen CDDL</name>
            <sourcecode type="cddl">
$$udpcl-ext-item //= (
    3: time-duration,
)
time-duration = uint
            </sourcecode>
          </figure>
          <t>
Unlike the generic source port requirement in <xref target="sec-udp-header"/>, when repeated Sender Listen are transmitted in a sequence a consistent source address-and-port <bcp14>SHALL</bcp14> be used.
          </t>
          <t>
The Sender Listen interval <bcp14>SHOULD</bcp14> be no shorter than 1 second and no longer than 60 seconds.
          </t>
          <t>
An entity <bcp14>SHOULD</bcp14> include an <xref format="title" target="sec-ext-support"/> and <xref format="title" target="sec-ext-sender-nodeid"/> item along with a Sender Listen item if the conditions of those extension types are met.
An entity <bcp14>MAY</bcp14> include any other extension type along with a Sender Listen item.
An entity <bcp14>SHALL NOT</bcp14> transmit a Sender Listen item before or along with a DTLS Initiate if DTLS is desired for a conversation.
          </t>
          <t>
This extension is not a neighbor discovery mechanism and does not indicate an entity listening generally on a particular UDP port.
Sender Listen applies only to UDP datagrams from the the peer address-and-port.
          </t>
        </section>
        <section anchor="sec-ext-sender-nodeid">
          <name>Sender Node ID</name>
          <t>
This extension item indicates the Node ID of the transmitter.
For DTLS-secured sessions (see <xref target="sec-dtls-authentication"/>) this extension can be used to disambiguate an end-entity certificate which has multiple NODE-ID values.
          </t>
          <t>
The Sender Node ID value <bcp14>SHALL</bcp14> be an untagged tstr value containing a Node ID.
Every Node ID <bcp14>SHALL</bcp14> be a URI consistent with the requirements of <xref target="RFC3986"/> and the URI schemes of the IANA "Bundle Protocol URI Scheme Type" registry <xref target="IANA-BUNDLE"/>.
          </t>
          <figure>
            <name>Sender Node ID CDDL</name>
            <sourcecode type="cddl">
$$udpcl-ext-item //= (
    4: nodeid,
)
nodeid = tstr
            </sourcecode>
          </figure>
          <t>
An entity <bcp14>SHOULD NOT</bcp14> include a Sender Node ID item if a DTLS session has already been established and the presented end-entity certificate contains a single NODE-ID.
In this case there is no ambiguity about which Node ID is identified by the certificate.
          </t>
          <t>
If an entity receives a peer Node ID which is not authenticated (by the procedure of <xref target="sec-dtls-authentication"/>) that Node ID <bcp14>SHOULD NOT</bcp14> be used by a BP agent for any discovery or routing functions.
Trusting an unauthenticated Node ID can lead to the threat described in <xref target="sec-threat-node-impersonation"/>.
          </t>
        </section>
        <section anchor="sec-ext-starttls">
          <name>DTLS Initiation (STARTTLS)</name>
          <t>
This extension item indicates that the transmitter is about to begin a DTLS handshake sequence in accordance with <xref target="sec-udpcl-security"/>.
          </t>
          <t>
The DTLS Initiation value <bcp14>SHALL</bcp14> be an untagged null value.
There are no DTLS parameters actually transmitted as part of this extension, it only serves to indicate to the recipient that the next datagram will be a DTLS ClientHello.
Although the datagram containing this extension is not retransmitted, the DTLS handshake itself will retransmit ClientHello messages until confirmation is received.
          </t>
          <figure>
            <name>DTLS Initiation CDDL</name>
            <sourcecode type="cddl">
$$udpcl-ext-item //= (
    5: null
)
            </sourcecode>
          </figure>
          <t>
If the entity is configured to enable exchanging messages according to DTLS 1.3 <xref target="RFC9147"/> or any successors which are compatible with that DTLS ClientHello, the first message in any sequence to a unicast recipient <bcp14>SHALL</bcp14> be an Extension Map with the DTLS Initiation item.
The RECOMMENDED policy is to enable DTLS for all unicast recipients, even if security policy does not allow or require authentication.
This follows the opportunistic security model of <xref target="RFC7435"/>, though an active attacker could interfere with the exchange in such cases (see <xref target="sec-threat-tls-strip"/>).
          </t>
          <t>
The Extension Map containing a DTLS Initiation item <bcp14>SHALL NOT</bcp14> contain any other items.
A DTLS Initiation item <bcp14>SHALL NOT</bcp14> be present in any message transmitted within a DTLS session.
A receiver of a DTLS Initiation item within a DTLS session <bcp14>SHALL</bcp14> ignore it.
Between transmitting a DTLS Initiation item and finishing a DTLS handshake (either success or failure) an entity <bcp14>SHALL NOT</bcp14> transmit any other UDP datagrams in that same conversation.
          </t>
        </section>
        <section anchor="sec-ext-peer-probe">
          <name>Peer Probe</name>
          <t>
This extension item provides the Probe Packet functionality of <xref section="4.1" target="RFC8899"/> in order to support path MTU discovery mechanism of <xref target="sec-plpmtud"/>.
          </t>
          <t>
The Peer Probe value <bcp14>SHALL</bcp14> be an array of three items.
The items are defined in the following order:
          </t>
          <dl>
            <dt>Nonce:</dt>
            <dd>
The first item <bcp14>SHALL</bcp14> be a <tt>uint</tt> nonce for correlating with <xref format="title" target="sec-ext-peer-ack"/> extensions.
            </dd>
            <dt>Sequence Number:</dt> 
            <dd>
The second item <bcp14>SHALL</bcp14> be a <tt>uint</tt> sequence number for the specific Probe packet.
            </dd>
            <dt>Confirmation Delay:</dt> 
            <dd>
The second item <bcp14>SHALL</bcp14> be a <tt>uint</tt> representing the desired confirmation delay time (in milliseconds).
            </dd>
          </dl>
          <figure>
            <name>Peer Probe CDDL</name>
            <sourcecode type="cddl">
$$udpcl-ext-item //= (
    6: [
        nonce,
        seqno,
        confirm-delay
    ],
)
; A correlator nonce for confirmations
nonce = uint
seqno = uint
confirm-delay = uint
            </sourcecode>
          </figure>
          <t>
When the Peer Probe item is present in a UDPCL packet, the Extension Map <bcp14>SHALL</bcp14> be the only message in the packet and it <bcp14>SHALL</bcp14> be followed by padding to a specific total size.
A transmitting entity <bcp14>SHALL</bcp14> use the same source and destination address-and-port for all UDPCL packets containing a Peer Probe with the same nonce value.
This is more strict than the requirements of <xref target="sec-udp-header"/> to ensure consistent confirmation behavior defined below.
          </t>
          <t>
The nonce value <bcp14>SHALL</bcp14> be used to correlate multiple Probe packets into a single sequence.
If an entity receives multiple unique nonce values from the same source address-and-port and the number of unique nonce values exceeds an upper limit, the receiving entity <bcp14>SHALL</bcp14> ignore the Probe.
The upper limit is implementation defined but <bcp14>SHOULD</bcp14> be no less than one unique nonce at-a-time.
          </t>
          <t>
If the confirmation delay time is above an upper limit the receiving entity <bcp14>SHALL</bcp14> ignore the Probe.
The upper limit is implementation defined but <bcp14>SHOULD</bcp14> be no shorter than one minute (60 seconds).
          </t>
          <t>
If an entity receives multiple instances of Peer Probe with the same nonce and sequence number values, the duplicates <bcp14>SHALL NOT</bcp14> be ignored.
This makes the last duplicate transmission of the last probe the basis of Peer Confirmation timing.
          </t>
          <t>
After an entity receives and validates a packet with a Peer Probe extension item it <bcp14>SHALL</bcp14> wait for the indicated confirmation delay time before sending a <xref format="title" target="sec-ext-peer-ack"/> item.
The enveloping UDPCL packet <bcp14>SHALL</bcp14> use the source address-and-port that sent the last Probe item as the destination of the Confirmation.
Once the Peer Confirmation packet is sent, the entity <bcp14>SHALL</bcp14> remove state associated with the Peer Probe items being confirmed.
This bounds the state on a confirming entity and makes each Peer Confirmation with the same nonce value incremental and not additive (<em>i.e.</em>, there will never be two Confirmations with the same nonce covering the same sequence numbers, except for duplicate transmissions).
          </t>
        </section>
        <section anchor="sec-ext-peer-ack">
          <name>Peer Confirmation</name>
          <t>
This extension item provides the Confirmation functionality of <xref section="4.2" target="RFC8899"/> in order to support path MTU discovery mechanism of <xref target="sec-plpmtud"/>.
          </t>
          <t>
The Peer Confirmation value <bcp14>SHALL</bcp14> be an array of two items.
The items are defined in the following order:
          </t>
          <dl>
            <dt>Nonce:</dt>
            <dd>
The first item <bcp14>SHALL</bcp14> be a <tt>uint</tt> nonce for correlating with <xref format="title" target="sec-ext-peer-probe"/> items. 
            </dd>
            <dt>Seen Sequence Range:</dt>
            <dd>
The second item <bcp14>SHALL</bcp14> be an array of pairs of <tt>uint</tt> values representing the range of sequence numbers of received Probe packets with the same nonce value.
            </dd>
          </dl>
          <t>
The encoding of ranges is a compressed form in which each pair of values indicates:
          </t>
          <ol>
            <li>
The non-zero offset from the previous one-past-end-of-interval, or the offset from zero if there is no preceding interval
            </li>
            <li>
The length of this interval, which is inclusive of the first and last contained sequence number so will always be positive
            </li>
          </ol>
          <figure>
            <name>Peer Confirmation CDDL</name>
            <sourcecode type="cddl">
$$udpcl-ext-item //= (
    7: [
        nonce,
        seen-range
    ],
)
; Range of sequence numbers seen
seen-range = [ + seen-interval-pair ]
seen-interval-pair = (
  offset: uint,
  length: uint .gt 0,
)
            </sourcecode>
          </figure>
          <t>
When an entity receives a packet with a Peer Confirmation extension item it <bcp14>SHALL</bcp14> wait for the same confirmation delay used in each Probe item for multiple Confirmation items with the same nonce.
Upon reception of all Confirmation items within the waiting delay, the entity <bcp14>SHALL</bcp14> treat the largest value of the seen range as the PMTU to the corresponding peer entity.
          </t>
        </section>
        <section anchor="sec-ext-ecn-counts">
          <name>ECN Counts</name>
          <t>
This extension item provides the ECN Feedback functionality of <xref section="4.2" target="RFC9331"/> in order to support congestion control feedback of <xref target="sec-pathchar-cc"/>.
          </t>
          <t>
The ECN Counts value <bcp14>SHALL</bcp14> be an array of three items.
The items are defined in the following order:
          </t>
          <dl>
            <dt>ECT(0) Count:</dt>
            <dd>
The first item <bcp14>SHALL</bcp14> be a <tt>uint</tt> count of packets marked with ECT(0) received from the peer, wrapped to 32-bits.
            </dd>
            <dt>ECT(1) Count:</dt>
            <dd>
The second item <bcp14>SHALL</bcp14> be a <tt>uint</tt> count of packets marked with ECT(1) received from the peer, wrapped to 32-bits.
            </dd>
            <dt>CE Count:</dt>
            <dd>
The third item <bcp14>SHALL</bcp14> be a <tt>uint</tt> count of packets marked with CE received from the peer, wrapped to 32-bits.
            </dd>
          </dl>
          <figure>
            <name>ECN Counts CDDL</name>
            <sourcecode type="cddl">
$$udpcl-ext-item //= (
    8: [
        ect0: ecn-count,
        ect1: ecn-count,
        ce: ecn-count
    ],
)
; Wraps around at 32-bits
ecn-count = uint .size 4
            </sourcecode>
          </figure>
          <t>
Because this extension type will only be used for feedback to a specific transmitting peer, it <bcp14>SHALL NOT</bcp14> be present in any UDPCL packet with an IP multicast destination.
          </t>
        </section>
      </section>
      <section anchor="sec-transfer">
        <name>Identified Transfers</name>
        <t>
This version of UDPCL supports CL-layer identification of bundles and segmentation of bundles larger than the PMTU would otherwise allow.
Policies related to segmentation at or fragmentation above, or below the UDPCL layer are defined in <xref target="sec-policy-fragmentation"/>.
The entire segmented bundle is referred to as a Transfer and individual segments of a transfer are encoded as Transfer extension items in accordance with <xref target="sec-ext-transfer"/>.
        </t>
        <t>
This mechanism also allows a bundle transfer to be transmitted along with additional extension items, which the unframed bundle-in-datagram data does not.
This specification does not define any extension items which augment an associated transfer.
        </t>
        <section anchor="sec-transfer-id">
          <name>Bundle Transfer ID</name>
          <t>
Each Transfer item contains a Transfer ID which is used to correlate messages for a single bundle transfer.
A Transfer ID does not attempt to address uniqueness of the bundle data itself and has no relation to concepts such as bundle fragmentation.
Each invocation of UDPCL by the BP agent, requesting transmission of a bundle (fragmentary or otherwise), can cause the initiation of a single UDPCL transfer.
          </t>
          <t>
Because UDPCL operation is connectionless, Transfer IDs from each entity <bcp14>SHALL</bcp14> be unique for the operating duration of the entity.
In practice, the ID needs only be unique for the longest receiver de-duplication and reassembly time window; but because that information is not part of the protocol there is no way for an transmitting entity to know the reassembly time window of any receiver (see <xref target="sec-transfer-segmentation"/>).
When there are bidirectional bundle transfers between UDPCL entities, an entity <bcp14>SHOULD NOT</bcp14> rely on any relation between Transfer IDs originating from each side of the conversation.
          </t>
          <t>
Although there is not a strict requirement for Transfer ID initial values or ordering (see <xref target="sec-security-xferid"/>), in the absence of any other mechanism for generating Transfer IDs an entity <bcp14>SHALL</bcp14> use the following algorithm:
the initial Transfer ID from each entity is zero;
subsequent Transfer ID values are incremented from the prior Transfer ID value by one;
upon exhaustion of the entire 32-bit Transfer ID space, the subsequent Transfer ID value is zero.
          </t>
        </section>
        <section anchor="sec-transfer-segmentation">
          <name>Segmentation and Reassembly</name>
          <t>
The full data content of a transfer <bcp14>SHALL</bcp14> be an unframed (BPv6 or BPv7) bundle as defined in <xref target="sec-udpcl-message"/>.
A receiving entity <bcp14>SHALL</bcp14> discard any reassembled transfer which does not properly contain a bundle as defined in <xref target="sec-udpcl-message"/>.
          </t>
          <t>
A transmitting entity <bcp14>MAY</bcp14> produce a Transfer with a single segment (i.e., a Segment Data size identical to the Total Length) in which case the redundant Transfer fields are omitted.
A transmitting entity <bcp14>SHALL NOT</bcp14> produce Transfer segments with overlapping span.
A transmitting entity <bcp14>SHOULD</bcp14> transmit Transfer segments in order of Segment Offset; this makes the behavior deterministic.
          </t>
          <t>
A receving entity <bcp14>SHALL</bcp14> maintain transfer reassembly state based on the tuple of packet source address-and-port and the Transfer ID sent by that source.
This relies on the stability of source port numbers at least for the duration of a single transfer, as required by <xref target="sec-ext-transfer"/>.
See <xref target="sec-policy-udp-convo"/> for options and implications of source port number use.
          </t>
          <t>
Because of the nature of UDP transport, there is no guaranteed order or timing of received Transfer items.
A receiving entity <bcp14>SHALL</bcp14> consider a transport as finished when Segment Data has been received which fully covers the Total Length of the transfer.
          </t>
          <t>
A receiving entity <bcp14>SHALL</bcp14> discard any Transfer item containing different CBOR types than defined in this document.
A receiving entity <bcp14>SHALL</bcp14> discard any Transfer item containing a segment with a span overlapping any other in the reassembly state.
That includes overlapping span because of a redundant transmission (see <xref target="sec-packet-redundancy"/>).
Because there is no feedback indication at the UDPCL layer, a transmitter has no indication when a Transfer item is discarded by the receiver.
          </t>
          <t>
A receiving entity <bcp14>SHOULD</bcp14> discard unfinished reassembly state after an implementation-defined timeout since the last received segment.
This timeout is purely receiver-side and represents the maximum allowed time between sequential received datagrams (in any order), which will be short if the datagrams take a similar network path.
A receiving entity <bcp14>SHALL NOT</bcp14> discard reassembly state upon successful completion of a transfer, in case the transmitting entity is sending redundant packets (<xref target="sec-packet-redundancy"/>) which need to be discarded.
Entities <bcp14>SHOULD</bcp14> choose a transfer timeout interval no longer than one minute (60 seconds).
Discarding an unfinished transfer causes no indication to the transmitting entity, but does indicate this to the receiving BP agent.
          </t>
        </section>
      </section>
      <section anchor="sec-pathchar">
        <name>Path Characterization Procedures</name>
        <t>
The procedures defined in this section allow pairs of UDPCL entities to characterize IP path parameters between them when those parameters are either unknown or for troubleshooting when actual network performance deviates from expectations.
        </t>
        <t>
These procedures not mandated to be used operationally, but when the associated characterization is desired these are the procedures which <bcp14>SHALL</bcp14> be used.
        </t>
        <section anchor="sec-plpmtud">
          <name>Packetization Layer Path MTU Discovery</name>
          <t>
This version of UDPCL is compatible with the requirements of Packetization Layer Path MTU Discovery (PLPMTUD) from <xref target="RFC8899"/>.
Specifically the UDPCL supports the requirements of <xref section="6.1" target="RFC8899"/> by using the <xref format="title" target="sec-ext-peer-probe"/> extension item to perform the probe behavior and <xref format="title" target="sec-ext-peer-ack"/> extension item for the confirmation behavior.
Because the Peer Confirmation acknowledges a possibly large range of Peer Probe packets, this makes the UDPCL less sensitive to large or time-variable path delays than if each Probe was separately acknowledged.
          </t>
          <t>
The use of PLPMTUD is especially helpful when DTLS is used to secure UDPCL conversations, as the DTLS confidentiality mechanism and associated record layer reduces the maximum packet size (MPS) by an amount depending upon the negotiated ciphersuite.
          </t>
          <t>
In case one or more Peer Probe items are sent but no corresponding Peer Confirmation is ever received, this might indicate that the peer has not implemented or enabled PLPMTUD and <bcp14>SHOULD NOT</bcp14> be treated as an indication that the peer is unreachable.
          </t>
        </section>
        <section anchor="sec-pathchar-delay">
          <name>Delay Time Estimation</name>
          <t>
The round-trip time (RTT) between two entities can be estimated by sending a sequence of small sized <xref format="title" target="sec-ext-peer-probe"/> items, each in its own UDPCL packet, with a small or zero Confirmation Delay and measuring the time taken to receive the corresponding <xref format="title" target="sec-ext-peer-ack"/> item.
          </t>
          <t>
The sequence <bcp14>MAY</bcp14> be as short as a single packet to get a point estimate of RTT.
Otherwise, the inter-packet interval at the sender <bcp14>SHALL</bcp14> be larger than the Confirmation Delay contained in each item.
This will cause each probe packet to correspond with a single related confirmation packet allowing either a time-series estimation or an average-over-time estimation of RTT.
          </t>
          <t>
Because there is no explicit time tagging of the acknowledgement, the one-way delay can be assumed to be one half of the RTT total.
          </t>
        </section>
        <section anchor="sec-pathchar-loss">
          <name>Throughput and Loss Estimation</name>
          <t>
The one-way packet loss between two entities can be estimated by sending a sequence of equally-sized <xref format="title" target="sec-ext-peer-probe"/> items, each in its own UDPCL packet, over some short time interval and observing how many of the probes have been seen in one or more corresponding <xref format="title" target="sec-ext-peer-ack"/> item.
For relatively low loss rates, a BER can be estimated by assuming each lost packet is caused by an equivalent to a single random error.
          </t>
          <t>
Similarly, a sequence of relatively large-sized (for the expected throughput order-of-magnitude) <xref format="title" target="sec-ext-peer-probe"/> items, each in its own UDPCL packet, and the total volume indicated by corresponding <xref format="title" target="sec-ext-peer-ack"/> items over some time interval can be used to estimate the one-way throughput limit.
          </t>
          <t>
For both cases above, the Probe packets can be combined with ECN markings as described in <xref target="sec-pathchar-cc"/> to ensure that losses or throughput limits are not related to intermediate queuing congestion.
          </t>
        </section>
        <section anchor="sec-pathchar-cc">
          <name>Congestion Control Feedback</name>
          <t>
AQM can be performed using "classic" ECN of <xref target="RFC3168"/> or with more advanced methods such as the ECN Protocol for Low Latency, Low Loss, and Scalable Throughput (L4S) of <xref target="RFC9331"/>.
These mechanisms allow for endpoints to implement internet-friendly congestion control with a small amount of application-level feedback of ECN data.
The ECN Counts extension of <xref target="sec-ext-ecn-counts"/> allows a UDPCL entity to both signal that it is ECN capable and to report ECN feedback in a way compatible with both <xref target="RFC3168"/> and <xref target="RFC9331"/>.
          </t>
          <t>
Because the information base defined below counts ECN values based on UDP conversation, the feedback occurs at the level of the entire conversation and not an individual message or bundle transfer within.
When present, any sending queues of a UDPCL entity <bcp14>SHALL</bcp14> be organized around the UDP conversation.
          </t>
          <t>
When an entity has enabled a congestion control mechanism, it <bcp14>SHALL</bcp14> mark outgoing IP packets with an ECN field of either ECT(0) or ECT(1) codepoint if they contain bundle data (either from an unframed transfer or an identified transfer <xref target="sec-ext-transfer"/>).
This marking is the signal that the sending entity is ECN capable and desires to receive ECN feedback.
          </t>
          <t>
When an entity has enabled ECN feedback and receives a UDPCL packet with a unicast IP destination and an ECN field other than the <em>Not-ECT</em> codepoint, the ECN field of the IP packet <bcp14>SHALL</bcp14> be used to update the entry of the ECN Feedback information table corresponding to its UDP Conversation.
When a new entry is needed in the ECN Feedback information table, the counts <bcp14>SHALL</bcp14> be initialized to zero.
          </t>
          <t>
When an entity has ECN feedback for a peer, it <bcp14>SHALL</bcp14> send ECN Counts extension items to that peer.
The ECN Counts extension <bcp14>MAY</bcp14> be sent periodically by a timer or when count values are increased above some threshold.
When triggered by timer, the minimum interval <bcp14>SHOULD</bcp14> be no shorter than 1 second.
When triggered by count change, the minimum increase <bcp14>SHOULD</bcp14> be no a change in CE Count being <cref>TBD</cref>% of the sum of the changes of ECT(0) Count and ECT(1) Count.
          </t>
          <t>
The information base for ECN Feedback information is a logical table containing the columns of <xref target="tab-info-ecn-counts"/>.
          </t>
          <table align="center" anchor="tab-info-ecn-counts">
            <name>ECN Feedback Information Columns</name>
            <thead>
              <tr>
                <th>Name</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>UDP Conversation</td>
                <td>This is the four-tuple of address-and-port for the remote and local UDP endpoints.</td>
              </tr>
              <tr>
                <td>ECT(0) Count</td>
                <td>
This is the total number of IP packets received in the UDP Conversation with the ECN field containing the ECT(0) codepoint.
                </td>
              </tr>
              <tr>
                <td>ECT(1) Count</td>
                <td>
This is the total number of IP packets received in the UDP Conversation with the ECN field containing the ECT(0) codepoint.
                </td>
              </tr>
              <tr>
                <td>CE Count</td>
                <td>
This is the total number of IP packets received in the UDP Conversation with the ECN field containing the CE codepoint.
                </td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="sec-udpcl-security">
        <name>UDPCL Security</name>
        <t>
This version of the UDPCL supports establishing a DTLS session within an existing UDP conversation.
When DTLS is used within the UDPCL it affects the entire conversation.
There is no concept of a plaintext message being sent in a conversation after a DTLS session is established.
        </t>
        <t>
Once established, the lifetime of a DTLS session <bcp14>SHALL</bcp14> be bound by the DTLS session ticket lifetime or either peer sending a Closure Alert record.
        </t>
        <t>
Subsequent DTLS session attempts to the same passive entity <bcp14>MAY</bcp14> attempt to use the DTLS session resumption feature.
There is no guarantee that the passive entity will accept the request to resume a DTLS session, and the active entity cannot assume any resumption outcome.
        </t>
        <section anchor="sec-dtls-identification">
          <name>Entity Identification</name>
          <t>
The UDPCL uses DTLS for certificate exchange in both directions to identify each entity and to allow each entity to authenticate its peer.
Each certificate can potentially identify multiple entities and there is no problem using such a certificate as long as the identifiers are sufficient to meet authentication policy (as described in later sections) for the entity which presents it.
          </t>
          <t>
The types and priorities of identities used by DTLS in UDPCL is the same as those for TLS in TCPCL as defined in <xref section="4.4.1" target="RFC9174"/>.
          </t>
        </section>
        <section anchor="sec-udpcl-cert-profile">
          <name>Certificate Profile for UDPCL</name>
          <t>
All end-entity certificates used by a UDPCL entity <bcp14>SHALL</bcp14> conform to the profile defined in <xref section="4.4.2" target="RFC9174"/>.
          </t>
        </section>
        <section anchor="sec-dtls-handshake">
          <name>DTLS Handshake</name>
          <t>
The signaling for DTLS Initiation is described in <xref target="sec-ext-starttls"/>.
After sending or receiving an Extension Map containing a DTLS Initiation item, an entity <bcp14>SHALL</bcp14> begin the handshake procedure of <xref section="5" target="RFC9147"/>.
By convention, this protocol uses the entity which sent the DTLS Initiation (the active peer) as the "client" role of the DTLS handshake request.
        </t>
          <t>
Upon receiving an unexpected ClientHello record outside of a DTLS session, an entity <bcp14>SHALL</bcp14> begin the DTLS handshake procedure as if a DTLS Initiation had been received.
This allows recovering from a dropped packet containing DTLS Initiation.
        </t>
        </section>
        <section anchor="sec-dtls-authentication">
          <name>DTLS Authentication</name>
          <t>
The function and mechanism of DTLS authentication in UDPCL is the same as for TLS in TCPCL as defined in <xref section="4.4.4" target="RFC9174"/>, with the exception that Node ID Authentication is based on an optional Sender Node ID extension (see <xref target="sec-ext-sender-nodeid"/>) used to disambiguate when an end-entity certificate contains multiple NODE-ID values.
        </t>
        </section>
        <section anchor="sec-dtls-auth-policy-rec">
          <name>Policy Recommendations</name>
          <t>
The policy recommendations given here are are the same as those for TCPCL in <xref section="4.4.5" target="RFC9174"/>.
They are restated in this document for clarity.
        </t>
          <t>
A RECOMMENDED security policy is to enable the use of OCSP checking during DTLS handshake.
A RECOMMENDED security policy is that if an Extended Key Usage is present that it needs to contain "id-kp-bundleSecurity" of <xref target="IANA-SMI"/> to be usable with UDPCL security.
A RECOMMENDED security policy is to require a validated NODE-ID and to ignore any network-level DNS-ID or IPADDR-ID.
        </t>
          <t>
This policy relies on and informs the certificate requirements in <xref target="sec-udpcl-cert-profile"/>.
This policy assumes that a DTN-aware CA (see <xref target="sec-pkix-env"/>) will only issue a certificate for a Node ID when it has verified that the private key holder actually controls the DTN node; this is needed to avoid the threat identified in <xref target="sec-threat-node-impersonation"/>.
This policy requires that a certificate contain a NODE-ID and allows the certificate to also contain network-level identifiers.
A tailored policy on a more controlled network could relax the requirement on Node ID validation and allow just network-level identifiers to authenticate a peer.
        </t>
        </section>
        <section>
          <name>Example Secured and Bidirectional Transfers</name>
          <t>
This simple example shows a sequence of pre-transfer setup followed by a set of (unrelated) bundle transfers.
All messaging in this example occurs between the same Entity A address-and-port and Entity B address-and-port.
          </t>
          <t>
The example Entity A has a policy to only send or receive bundles within a DTLS session, so any outgoing bundles to Entity B are queued until the DTLS session is established.
Because Entity A is willing to accept transfers on its ephemeral UDP port, the first outgoing message after the DTLS handshake contains the Sender Listen extension (along with a Sender Node ID indicating its identity to Entity B).
          </t>
          <figure anchor="fig-conversation-example">
            <name>An example of the flow of protocol messages on a single UDP conversation between two entities</name>
            <artwork align="center" type="ascii-art">
         Entity A                             Entity B
        active peer                         passive peer

+-------------------------+
|    Initiate DTLS Ext.   | -&gt;
+-------------------------+
+-------------------------+         +-------------------------+
|     DTLS Negotiation    | -&gt;   &lt;- |     DTLS Negotiation    |
|       (as client)       |         |       (as server)       |
+-------------------------+         +-------------------------+

           DNS-ID and IPADDR-ID authentication occurs.
               Secured UDPCL messaging can begin.

+-------------------------+
|   Sender Listen Ext.    | -&gt;
|   Sender Node ID Ext.   |
+-------------------------+

                  NODE-ID authentication occurs.
         DTLS session is established, transfers can begin.

+-------------------------+
|    Unframed Transfer    | -&gt;      +-------------------------+
+-------------------------+      &lt;- |    Unframed Transfer    |
+-------------------------+         +-------------------------+
|    Unframed Transfer    | -&gt;
+-------------------------+
</artwork>
          </figure>
        </section>
      </section>
    </section>
    <section removeInRFC="true">
      <name>Implementation Status</name>
      <t>
[NOTE to the RFC Editor: please remove this section before publication, as well as the reference to <xref target="RFC7942"/>, <xref target="github-dtn-demo-agent"/>, and <xref target="github-dtn-wireshark"/>.]
      </t>
      <t>
This section records the status of known implementations of the protocol defined by this specification at the time of posting of this Internet-Draft, and is based on a proposal described in <xref target="RFC7942"/>.
The description of implementations in this section is intended to assist the IETF in its decision processes in progressing drafts to RFCs.
Please note that the listing of any individual implementation here does not imply endorsement by the IETF.
Furthermore, no effort has been spent to verify the information presented here that was supplied by IETF contributors.
This is not intended as, and must not be construed to be, a catalog of available implementations or their features.
Readers are advised to note that other implementations can exist.
      </t>
      <t>
An example implementation of the this draft of UDPCL has been created as a GitHub project <xref target="github-dtn-demo-agent"/> and is intended to use as a proof-of-concept and as a possible source of interoperability testing.
This example implementation uses D-Bus as the CL-BP Agent interface, so it only runs on hosts which provide the Python "dbus" library.
      </t>
      <t>
A wireshark dissector for UDPCL has been created as a GitHub project <xref target="github-dtn-wireshark"/> and has been kept in-sync with the latest encoding of this specification.
      </t>
    </section>
    <section anchor="sec-security">
      <name>Security Considerations</name>
      <t>
This section separates security considerations into threat categories based on guidance of BCP 72 <xref target="RFC3552"/>.
      </t>
      <section>
        <name>Threat: Passive Leak of Node Data</name>
        <t>
When used without DTLS security, the UDPCL can expose the Node ID and other configuration data to passive eavesdroppers.
This can occur even if no bundle transfers are transmitted.
This can be avoided by always using DTLS, even if authentication is not available (see <xref target="sec-security-tlsalt"/>).
        </t>
      </section>
      <section>
        <name>Threat: Passive Leak of Bundle Data</name>
        <t>
UDPCL can be used to provide point-to-point unicast transport security, but does not provide multicast security, security of data-at-rest, and does not guarantee end-to-end bundle security.
In those cases the bundle security mechanisms defined in <xref target="RFC9172"/> are to be used instead.
        </t>
        <t>
When used without DTLS security, the UDPCL exposes all bundle data to passive eavesdroppers.
This can be avoided by always using DTLS for unicast messaging, even if authentication is not available (see <xref target="sec-security-tlsalt"/>).
        </t>
      </section>
      <section anchor="sec-threat-tls-strip">
        <name>Threat: Transport Security Stripping</name>
        <t>
When security policy allows non-DTLS messaging, UDPCL does not protect against active network attackers.
It is possible for a on-path attacker to drop or alter packets containing Extension Map and/or DTLS handshake records, which will cause the receiver to not negotiate a DTLS session.
This leads to the "SSL Stripping" attack described in <xref target="RFC7457"/>.
        </t>
        <t>
When DTLS is available on an entity, it is strongly encouraged that the security policy disallow non-DTLS messaging for unicast purposes.
This requires that the DTLS handshake occurs before any other UDPCL messaging, regardless of the policy-driven parameters of the handshake and policy-driven handling of the handshake outcome.
        </t>
        <t>
One mechanism to mitigate the possibility of DTLS stripping is the use of DNS-based Authentication of Named Entities (DANE) <xref target="RFC6698"/> toward the passive peer.
This mechanism relies on DNS and is unidirectional, so it doesn't help with applying policy toward the active peer, but it can be useful in an environment using opportunistic security.
The configuration and use of DANE are outside of the scope of this document.
        </t>
        <t>
The negotiated use of DTLS is identical behavior to STARTTLS use in <xref target="RFC2595"/>, <xref target="RFC4511"/>, and others.
        </t>
      </section>
      <section>
        <name>Threat: Weak DTLS Configurations</name>
        <t>
Even when using DTLS to secure the UDPCL session, the actual ciphersuite negotiated between the DTLS peers can be insecure.
Recommendations for ciphersuite use are included in BCP 195 <xref target="RFC7525"/>.
It is up to security policies within each UDPCL entity to ensure that the negotiated DTLS ciphersuite meets transport security requirements.
        </t>
      </section>
      <section anchor="sec-threat-untrust-cert">
        <name>Threat: Untrusted End-Entity Certificate</name>
        <t>
The profile in <xref target="sec-dtls-authentication"/> uses end-entity certificates chained up to a trusted root CA.
During DTLS handshake, either entity can send a certificate set which does not contain the full chain, possibly excluding intermediate or root CAs.
In an environment where peers are known to already contain needed root and intermediate CAs there is no need to include those CAs, but this has a risk of an entity not actually having one of the needed CAs.
        </t>
      </section>
      <section>
        <name>Threat: Certificate Validation Vulnerabilities</name>
        <t>
Even when DTLS itself is operating properly an attacker can attempt to exploit vulnerabilities within certificate check algorithms or configuration to establish a secure DTLS session using an invalid certificate.
An invalid certificate exploit could lead to bundle data leaking and/or denial of service to the Node ID being impersonated.
        </t>
        <t>
There are many reasons, described in <xref target="RFC5280"/> and <xref target="RFC6125"/>, why a certificate can fail to validate, including using the certificate outside of its valid time interval, using purposes for which it was not authorized, or using it after it has been revoked by its CA.
Validating a certificate is a complex task and can require network connectivity outside of the primary UDPCL network path(s) if a mechanism such as OCSP <xref target="RFC6960"/> is used by the CA.
The configuration and use of particular certificate validation methods are outside of the scope of this document.
        </t>
      </section>
      <section anchor="sec-threat-node-impersonation">
        <name>Threat: BP Node Impersonation</name>
        <t>
The certificates exchanged by DTLS enable authentication of peer DNS name and Node ID, but it is possible that a peer either not provide a valid certificate or that the certificate does not validate either the DNS-ID/IPADDR-ID or NODE-ID of the peer (see <xref target="sec-pkix-env"/>).
Having a CA-validated certificate does not alone guarantee the identity of the network host or BP node from which the certificate is provided; additional validation procedures in <xref target="sec-dtls-handshake"/> bind the DNS-ID/IPADDR-ID or NODE-ID based on the contents of the certificate.
        </t>
        <t>
The DNS-ID/IPADDR-ID validation is a weaker form of authentication, because even if a peer is operating on an authenticated network DNS name or IP address it can provide an invalid Node ID and cause bundles to be "leaked" to an invalid node.
Especially in DTN environments, network names and addresses of nodes can be time-variable so binding a certificate to a Node ID is a more stable identity.
        </t>
        <t>
NODE-ID validation ensures that the peer to which a bundle is transferred is in fact the node which the BP Agent expects it to be.
In circumstances where certificates can only be issued to DNS names, Node ID validation is not possible but it could be reasonable to assume that a trusted host is not going to present an invalid Node ID.
Determining when a DNS-ID/IPADDR-ID authentication can be trusted to validate a Node ID is also a policy matter outside of the scope of this document.
        </t>
        <t>
One mitigation to arbitrary entities with valid PKIX certificates impersonating arbitrary Node IDs is the use of the PKIX Extended Key Usage key purpose "id-kp-bundleSecurity" of <xref target="IANA-SMI"/>.
When this Extended Key Usage is present in the certificate, it represents a stronger assertion that the private key holder is trusted to operate as a DTN Node.
        </t>
      </section>
      <section anchor="sec-threat-injection">
        <name>Threat: Off-Path Packet Injection</name>
        <t>
As described in <xref section="5.1" target="RFC8085"/>, when each endpoint of a UDP conversation uses a stable port number the conversation can be more easily snooped and off-path packets can be injected to spoof UDPCL traffic.
When the requirements in <xref target="sec-udp-header"/> are followed UDPCL traffic will use predictable, well-known port numbers and will be subject to this threat.
        </t>
        <t>
One direct mitigation of this threat is to use DTLS to ensure that off-path attackers cannot inject packets without being discovered and those packets rejected at the destination.
        </t>
        <t>
Another mitigation is for a UDPCL entity to use the well-known UDPCL port for passive listening but choose an ephemeral port to bind to when acting as the active peer.
This will enable some amount of obfuscation while maintaining stable UDP conversations, but could also make legitimate traffic analysis and troubleshooting more difficult.
        </t>
      </section>
      <section anchor="sec-threat-dos">
        <name>Threat: Denial of Service</name>
        <t>
The behaviors described in this section all amount to a potential denial-of-service to a UDPCL entity.
The denial-of-service could be limited to an individual UDPCL entity, or could affect all entities on a host or network segment.
        </t>
        <t>
An entity can send a large amount of data to a UDPCL entity, requiring the receiving entity to handle the data.
The victim entity can block UDP packets from network peers which are thought to be incorrectly behaving within network.
        </t>
        <t>
An entity can also send only one segment of a seemingly valid transfer and never send the remaining segments, which will cause resources on the receiver to be wasted on transfer reassembly state.
The victim entity can either block packets from network peers or intentionally keep a short unfinished transfer timeout (see <xref target="sec-transfer-segmentation"/>).
        </t>
        <t>
The keepalive mechanism can be abused to waste throughput within a network link which would otherwise be usable for bundle transmissions.
        </t>
      </section>
      <section anchor="sec-security-dtls-mandate">
        <name>Mandatory-to-Implement DTLS</name>
        <t>
Following IETF best current practice, DTLS is mandatory to implement for all UDPCL implementations but DTLS is optional to use for a any given transfer.
The recommended configuration of <xref target="sec-ext-starttls"/> is to always attempt DTLS, but entities are permitted to disable DTLS based on local configuration.
The configuration to enable or disable DTLS for an entity or a session is outside of the scope of this document.
The configuration to disable DTLS is different from the threat of DTLS stripping described in <xref target="sec-threat-tls-strip"/>.
        </t>
      </section>
      <section anchor="sec-security-tlsalt">
        <name>Alternate Uses of DTLS</name>
        <t>
This specification makes use of PKIX certificate validation and authentication within DTLS.
There are alternate uses of DTLS which are not necessarily incompatible with the security goals of this specification, but are outside of the scope of this document.
The following subsections give examples of alternate DTLS uses.
        </t>
        <section anchor="sec-security-tlsnoauth">
          <name>DTLS Without Authentication</name>
          <t> In environments where PKI is available but there are restrictions on the issuance of certificates (including the contents of certificates), it can be possible to make use of DTLS in a way which authenticates only the passive entity of a UDPCL transfer or which does not authenticate either entity.
Using DTLS in a way which does not successfully authenticate some claim of both peer entities of a UDPCL transfer is outside of the scope of this document but does have similar properties to the opportunistic security model of <xref target="RFC7435"/>.
          </t>
        </section>
        <section anchor="sec-security-tlsnopki">
          <name>Non-Certificate DTLS Use</name>
          <t>
In environments where PKI is unavailable, alternate uses of DTLS which do not require certificates such as pre-shared key (PSK) authentication <xref target="RFC5489"/> and the use of raw public keys <xref target="RFC7250"/> are available and can be used to ensure confidentiality within UDPCL.
Using non-PKI node authentication methods is outside of the scope of this document.
          </t>
        </section>
      </section>
      <section anchor="sec-security-xferid">
        <name>Predictability of Transfer IDs</name>
        <t>
The only requirement on Transfer IDs is that they are unique from the transmitting peer only.
The trivial algorithm of the first transfer starting at zero and later transfers incrementing by one causes absolutely predictable Transfer IDs.
Even when UDPCL is not DTLS secured and there is a on-path attacker altering UDPCL messages, there is no UDPCL feedback mechanism to interrupt or refuse a transfer so there is no benefit in having unpredictable Transfer IDs.
        </t>
      </section>
    </section>
    <section anchor="sec-iana">
      <name>IANA Considerations</name>
      <t>
Registration procedures referred to in this section are defined in <xref target="RFC8126"/>.
      </t>
      <section anchor="sec-iana-ip-mcast">
        <name>IP Multicast Addresses</name>
        <t>
This document allocates new routable multicast addresses for use with the UDPCL.
        </t>
        <t>
Within the IPv4 multicast address registry of <xref target="IANA-IPv4-MCAST"/>, the sub-registry titled "Internetwork Control Block" has been updated to include the following address.
        </t>
        <table align="center">
          <thead>
            <tr>
              <th>Parameter</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Address(es):</td>
              <td>TBA-IP4</td>
            </tr>
            <tr>
              <td>Description:</td>
              <td>All BP Nodes</td>
            </tr>
            <tr>
              <td>References:</td>
              <td>[This specification]</td>
            </tr>
          </tbody>
        </table>
        <t>
Within the IPv6 multicast address registry of <xref target="IANA-IPv6-MCAST"/>, the sub-registry titled "Variable Scope Multicast Addresses" has been updated to include the following address.
        </t>
        <table align="center">
          <thead>
            <tr>
              <th>Parameter</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Address(es):</td>
              <td>TBA-IP6</td>
            </tr>
            <tr>
              <td>Description:</td>
              <td>All BP Nodes</td>
            </tr>
            <tr>
              <td>References:</td>
              <td>[This specification]</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="sec-iana-udp-port">
        <name>UDP Port Number</name>
        <t>
Within the port registry of <xref target="IANA-PORTS"/>, UDP port number 4556 has been previously assigned as the default port for the UDP convergence layer in <xref target="RFC7122"/>.
This assignment to UDPCL is unchanged, but the assignment reference is updated to this specification.
There is no UDPCL version indication on-the-wire but this specification is a superset of <xref target="RFC7122"/> and is fully backward compatible.
        </t>
        <dl newline="true">
          <dt>Service Name:</dt>
          <dd>dtn-bundle</dd>
          <dt>Transport Protocol(s):</dt>
          <dd>UDP</dd>
          <dt>Assignee:</dt>
          <dd>IESG &lt;iesg@ietf.org&gt;</dd>
          <dt>Contact:</dt>
          <dd>IETF Chair &lt;chair@ietf.org&gt;</dd>
          <dt>Description:</dt>
          <dd>DTN Bundle UDP CL Protocol</dd>
          <dt>Reference:</dt>
          <dd>[This specification]</dd>
          <dt>Port Number:</dt>
          <dd>4556</dd>
        </dl>
        <t>
The related assignment for DCCP port 4556 (registered by <xref target="RFC7122"/>) is unchanged.
        </t>
      </section>
      <section anchor="sec-iana-extension-types">
        <name>UDPCL Extension Types</name>
        <t>EDITOR NOTE: sub-registry to-be-created upon publication of this specification.</t>
        <t>
IANA will create, under the "Bundle Protocol" registry <xref target="IANA-BUNDLE"/>, a sub-registry titled "Bundle Protocol UDP Convergence-Layer Extension Types" and initialize it with the contents of <xref target="tab-iana-extension-types"/>.
For positive code points the registration procedure is Specification Required.
Negative code points are reserved for use on private networks for functions not published to the IANA.
        </t>
        <t>
Specifications of new extension types need to define the CBOR item structure of the extension data as well as the purpose and relationship of the new extension to existing session/transfer state within the baseline UDPCL sequencing.
Receiving entities will ignore items with unknown Extension ID, and that behavior needs to be considered by new extension types.
        </t>
        <t>
Expert(s) are encouraged to be biased towards approving registrations unless they are abusive, frivolous, or actively harmful (not merely aesthetically displeasing, or architecturally dubious).
        </t>
        <table align="center" anchor="tab-iana-extension-types">
          <name>Extension Type Codes</name>
          <thead>
            <tr>
              <th>Extension ID</th>
              <th>Name</th>
              <th>References</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>-32768 to -1</td>
              <td>Private/Experimental Use</td>
              <td>[This specification]</td>
            </tr>
            <tr>
              <td>0</td>
              <td>Reserved</td>
              <td>[This specification]</td>
            </tr>
            <tr>
              <td>1</td>
              <td>Extension Support</td>
              <td><xref target="sec-ext-support"/> of [this specification]</td>
            </tr>
            <tr>
              <td>2</td>
              <td>Transfer</td>
              <td><xref target="sec-ext-transfer"/> of [this specification]</td>
            </tr>
            <tr>
              <td>3</td>
              <td>Sender Listen</td>
              <td><xref target="sec-ext-sender-listen"/> of [this specification]</td>
            </tr>
            <tr>
              <td>4</td>
              <td>Sender Node ID</td>
              <td><xref target="sec-ext-sender-nodeid"/> of [this specification]</td>
            </tr>
            <tr>
              <td>5</td>
              <td>DTLS Initiation (STARTTLS)</td>
              <td><xref target="sec-ext-starttls"/> of [this specification]</td>
            </tr>
            <tr>
              <td>6</td>
              <td>Peer Probe</td>
              <td><xref target="sec-ext-peer-probe"/> of [this specification]</td>
            </tr>
            <tr>
              <td>7</td>
              <td>Peer Confirmation</td>
              <td><xref target="sec-ext-peer-ack"/> of [this specification]</td>
            </tr>
            <tr>
              <td>8</td>
              <td>ECN Counts</td>
              <td><xref target="sec-ext-ecn-counts"/> of [this specification]</td>
            </tr>
            <tr>
              <td>9 to 32767</td>
              <td>Unassigned</td>
              <td/>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="IANA-BUNDLE" target="https://www.iana.org/assignments/bundle/">
          <front>
            <title>Bundle Protocol</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="IANA-PORTS" target="https://www.iana.org/assignments/service-names-port-numbers/">
          <front>
            <title>Service Name and Transport Protocol Port Number Registry</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="IANA-IPv4-MCAST" target="https://www.iana.org/assignments/multicast-addresses/">
          <front>
            <title>IPv4 Multicast Address Space Registry</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="IANA-IPv6-MCAST" target="https://www.iana.org/assignments/ipv6-multicast-addresses/">
          <front>
            <title>IPv6 Multicast Address Space Registry</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="IANA-SMI" target="https://www.iana.org/assignments/smi-numbers/">
          <front>
            <title>Structure of Management Information (SMI) Numbers</title>
            <author>
              <organization>IANA</organization>
            </author>
            <date/>
          </front>
        </reference>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0768.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1122.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3168.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5050.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5280.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6125.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6960.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7525.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8085.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8610.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8899.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8949.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.9147.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.9171.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.9174.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.9331.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.792.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2595.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3542.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4443.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4511.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4838.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5489.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6698.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7122.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7250.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7435.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7457.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7942.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8445.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8489.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8900.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.9172.xml"/>
        <reference anchor="github-dtn-demo-agent" target="https://github.com/BSipos-RKF/dtn-demo-agent/">
          <front>
            <title>UDPCL Example Implementation</title>
            <author fullname="Brian Sipos" initials="B." surname="Sipos">
              <organization abbrev="RKF Engineering">
              RKF Engineering Solutions, LLC
              </organization>
            </author>
            <date/>
          </front>
        </reference>
        <reference anchor="github-dtn-wireshark" target="https://github.com/BSipos-RKF/dtn-wireshark/">
          <front>
            <title>UDPCL Wireshark Dissector</title>
            <author fullname="Brian Sipos" initials="B." surname="Sipos">
              <organization abbrev="RKF Engineering">
              RKF Engineering Solutions, LLC
              </organization>
            </author>
            <date/>
          </front>
        </reference>
      </references>
    </references>
    <section>
      <name>Significant changes from RFC7122</name>
      <t>
The areas in which changes from <xref target="RFC7122"/> have been made to existing requirements:
      </t>
      <ul spacing="normal">
        <li>Made explicit references to UDP- and IP-related RFCs.</li>
        <li>Made more strict Keepalive and Padding requirements.</li>
        <li>Added Extension Map message type and initial extension types.</li>
        <li>Defined UDPCL security and made it mandatory-to-implement but optional to use.</li>
      </ul>
      <t>
The areas in which extensions from <xref target="RFC7122"/> have been made as new behaviors are:
      </t>
      <ul spacing="normal">
        <li>Added BPv7 bundle as a possible UDPCL payload.</li>
        <li>Added discussion about optional explicit redundancy in transmission.</li>
        <li>Added discussion about optional path MTU discovery.</li>
        <li>Added discussion about optional congestion control feedback.</li>
        <li>Defined semantics for IP multicast addressing.</li>
        <li>Defined recommendations for UDP port use and re-use (port stability).</li>
      </ul>
    </section>
    <section anchor="sec-doc-ack" numbered="false">
      <name>Acknowledgments</name>
      <t>
Much pre-draft review was performed to make the document clear and readable by Sarah Heiner of JHU/APL.
       </t>
    </section>
  </back>
</rfc>
